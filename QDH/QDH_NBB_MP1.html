<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />

<meta name="author" content="Nik Bear Brown" />


<title>Quantitive Data Humanism with Pokemon</title>

<script>// Hide empty <a> tag within highlighted CodeBlock for screen reader accessibility (see https://github.com/jgm/pandoc/issues/6352#issuecomment-626106786) -->
// v0.0.1
// Written by JooYoung Seo (jooyoung@psu.edu) and Atsushi Yasumoto on June 1st, 2020.

document.addEventListener('DOMContentLoaded', function() {
  const codeList = document.getElementsByClassName("sourceCode");
  for (var i = 0; i < codeList.length; i++) {
    var linkList = codeList[i].getElementsByTagName('a');
    for (var j = 0; j < linkList.length; j++) {
      if (linkList[j].innerHTML === "") {
        linkList[j].setAttribute('aria-hidden', 'true');
      }
    }
  }
});
</script>
<style type="text/css">
a.anchor-section {margin-left: 10px; visibility: hidden; color: inherit;}
a.anchor-section::before {content: '#';}
.hasAnchor:hover a.anchor-section {visibility: visible;}
</style>
<script>// Anchor sections v1.0 written by Atsushi Yasumoto on Oct 3rd, 2020.
document.addEventListener('DOMContentLoaded', function() {
  // Do nothing if AnchorJS is used
  if (typeof window.anchors === 'object' && anchors.hasOwnProperty('hasAnchorJSLink')) {
    return;
  }

  const h = document.querySelectorAll('h1, h2, h3, h4, h5, h6');

  // Do nothing if sections are already anchored
  if (Array.from(h).some(x => x.classList.contains('hasAnchor'))) {
    return null;
  }

  // Use section id when pandoc runs with --section-divs
  const section_id = function(x) {
    return ((x.classList.contains('section') || (x.tagName === 'SECTION'))
            ? x.id : '');
  };

  // Add anchors
  h.forEach(function(x) {
    const id = x.id || section_id(x.parentElement);
    if (id === '') {
      return null;
    }
    let anchor = document.createElement('a');
    anchor.href = '#' + id;
    anchor.classList = ['anchor-section'];
    x.classList.add('hasAnchor');
    x.appendChild(anchor);
  });
});
</script>
<script>(function() {
  // If window.HTMLWidgets is already defined, then use it; otherwise create a
  // new object. This allows preceding code to set options that affect the
  // initialization process (though none currently exist).
  window.HTMLWidgets = window.HTMLWidgets || {};

  // See if we're running in a viewer pane. If not, we're in a web browser.
  var viewerMode = window.HTMLWidgets.viewerMode =
      /\bviewer_pane=1\b/.test(window.location);

  // See if we're running in Shiny mode. If not, it's a static document.
  // Note that static widgets can appear in both Shiny and static modes, but
  // obviously, Shiny widgets can only appear in Shiny apps/documents.
  var shinyMode = window.HTMLWidgets.shinyMode =
      typeof(window.Shiny) !== "undefined" && !!window.Shiny.outputBindings;

  // We can't count on jQuery being available, so we implement our own
  // version if necessary.
  function querySelectorAll(scope, selector) {
    if (typeof(jQuery) !== "undefined" && scope instanceof jQuery) {
      return scope.find(selector);
    }
    if (scope.querySelectorAll) {
      return scope.querySelectorAll(selector);
    }
  }

  function asArray(value) {
    if (value === null)
      return [];
    if ($.isArray(value))
      return value;
    return [value];
  }

  // Implement jQuery's extend
  function extend(target /*, ... */) {
    if (arguments.length == 1) {
      return target;
    }
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var prop in source) {
        if (source.hasOwnProperty(prop)) {
          target[prop] = source[prop];
        }
      }
    }
    return target;
  }

  // IE8 doesn't support Array.forEach.
  function forEach(values, callback, thisArg) {
    if (values.forEach) {
      values.forEach(callback, thisArg);
    } else {
      for (var i = 0; i < values.length; i++) {
        callback.call(thisArg, values[i], i, values);
      }
    }
  }

  // Replaces the specified method with the return value of funcSource.
  //
  // Note that funcSource should not BE the new method, it should be a function
  // that RETURNS the new method. funcSource receives a single argument that is
  // the overridden method, it can be called from the new method. The overridden
  // method can be called like a regular function, it has the target permanently
  // bound to it so "this" will work correctly.
  function overrideMethod(target, methodName, funcSource) {
    var superFunc = target[methodName] || function() {};
    var superFuncBound = function() {
      return superFunc.apply(target, arguments);
    };
    target[methodName] = funcSource(superFuncBound);
  }

  // Add a method to delegator that, when invoked, calls
  // delegatee.methodName. If there is no such method on
  // the delegatee, but there was one on delegator before
  // delegateMethod was called, then the original version
  // is invoked instead.
  // For example:
  //
  // var a = {
  //   method1: function() { console.log('a1'); }
  //   method2: function() { console.log('a2'); }
  // };
  // var b = {
  //   method1: function() { console.log('b1'); }
  // };
  // delegateMethod(a, b, "method1");
  // delegateMethod(a, b, "method2");
  // a.method1();
  // a.method2();
  //
  // The output would be "b1", "a2".
  function delegateMethod(delegator, delegatee, methodName) {
    var inherited = delegator[methodName];
    delegator[methodName] = function() {
      var target = delegatee;
      var method = delegatee[methodName];

      // The method doesn't exist on the delegatee. Instead,
      // call the method on the delegator, if it exists.
      if (!method) {
        target = delegator;
        method = inherited;
      }

      if (method) {
        return method.apply(target, arguments);
      }
    };
  }

  // Implement a vague facsimilie of jQuery's data method
  function elementData(el, name, value) {
    if (arguments.length == 2) {
      return el["htmlwidget_data_" + name];
    } else if (arguments.length == 3) {
      el["htmlwidget_data_" + name] = value;
      return el;
    } else {
      throw new Error("Wrong number of arguments for elementData: " +
        arguments.length);
    }
  }

  // http://stackoverflow.com/questions/3446170/escape-string-for-use-in-javascript-regex
  function escapeRegExp(str) {
    return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
  }

  function hasClass(el, className) {
    var re = new RegExp("\\b" + escapeRegExp(className) + "\\b");
    return re.test(el.className);
  }

  // elements - array (or array-like object) of HTML elements
  // className - class name to test for
  // include - if true, only return elements with given className;
  //   if false, only return elements *without* given className
  function filterByClass(elements, className, include) {
    var results = [];
    for (var i = 0; i < elements.length; i++) {
      if (hasClass(elements[i], className) == include)
        results.push(elements[i]);
    }
    return results;
  }

  function on(obj, eventName, func) {
    if (obj.addEventListener) {
      obj.addEventListener(eventName, func, false);
    } else if (obj.attachEvent) {
      obj.attachEvent(eventName, func);
    }
  }

  function off(obj, eventName, func) {
    if (obj.removeEventListener)
      obj.removeEventListener(eventName, func, false);
    else if (obj.detachEvent) {
      obj.detachEvent(eventName, func);
    }
  }

  // Translate array of values to top/right/bottom/left, as usual with
  // the "padding" CSS property
  // https://developer.mozilla.org/en-US/docs/Web/CSS/padding
  function unpackPadding(value) {
    if (typeof(value) === "number")
      value = [value];
    if (value.length === 1) {
      return {top: value[0], right: value[0], bottom: value[0], left: value[0]};
    }
    if (value.length === 2) {
      return {top: value[0], right: value[1], bottom: value[0], left: value[1]};
    }
    if (value.length === 3) {
      return {top: value[0], right: value[1], bottom: value[2], left: value[1]};
    }
    if (value.length === 4) {
      return {top: value[0], right: value[1], bottom: value[2], left: value[3]};
    }
  }

  // Convert an unpacked padding object to a CSS value
  function paddingToCss(paddingObj) {
    return paddingObj.top + "px " + paddingObj.right + "px " + paddingObj.bottom + "px " + paddingObj.left + "px";
  }

  // Makes a number suitable for CSS
  function px(x) {
    if (typeof(x) === "number")
      return x + "px";
    else
      return x;
  }

  // Retrieves runtime widget sizing information for an element.
  // The return value is either null, or an object with fill, padding,
  // defaultWidth, defaultHeight fields.
  function sizingPolicy(el) {
    var sizingEl = document.querySelector("script[data-for='" + el.id + "'][type='application/htmlwidget-sizing']");
    if (!sizingEl)
      return null;
    var sp = JSON.parse(sizingEl.textContent || sizingEl.text || "{}");
    if (viewerMode) {
      return sp.viewer;
    } else {
      return sp.browser;
    }
  }

  // @param tasks Array of strings (or falsy value, in which case no-op).
  //   Each element must be a valid JavaScript expression that yields a
  //   function. Or, can be an array of objects with "code" and "data"
  //   properties; in this case, the "code" property should be a string
  //   of JS that's an expr that yields a function, and "data" should be
  //   an object that will be added as an additional argument when that
  //   function is called.
  // @param target The object that will be "this" for each function
  //   execution.
  // @param args Array of arguments to be passed to the functions. (The
  //   same arguments will be passed to all functions.)
  function evalAndRun(tasks, target, args) {
    if (tasks) {
      forEach(tasks, function(task) {
        var theseArgs = args;
        if (typeof(task) === "object") {
          theseArgs = theseArgs.concat([task.data]);
          task = task.code;
        }
        var taskFunc = tryEval(task);
        if (typeof(taskFunc) !== "function") {
          throw new Error("Task must be a function! Source:\n" + task);
        }
        taskFunc.apply(target, theseArgs);
      });
    }
  }

  // Attempt eval() both with and without enclosing in parentheses.
  // Note that enclosing coerces a function declaration into
  // an expression that eval() can parse
  // (otherwise, a SyntaxError is thrown)
  function tryEval(code) {
    var result = null;
    try {
      result = eval(code);
    } catch(error) {
      if (!error instanceof SyntaxError) {
        throw error;
      }
      try {
        result = eval("(" + code + ")");
      } catch(e) {
        if (e instanceof SyntaxError) {
          throw error;
        } else {
          throw e;
        }
      }
    }
    return result;
  }

  function initSizing(el) {
    var sizing = sizingPolicy(el);
    if (!sizing)
      return;

    var cel = document.getElementById("htmlwidget_container");
    if (!cel)
      return;

    if (typeof(sizing.padding) !== "undefined") {
      document.body.style.margin = "0";
      document.body.style.padding = paddingToCss(unpackPadding(sizing.padding));
    }

    if (sizing.fill) {
      document.body.style.overflow = "hidden";
      document.body.style.width = "100%";
      document.body.style.height = "100%";
      document.documentElement.style.width = "100%";
      document.documentElement.style.height = "100%";
      if (cel) {
        cel.style.position = "absolute";
        var pad = unpackPadding(sizing.padding);
        cel.style.top = pad.top + "px";
        cel.style.right = pad.right + "px";
        cel.style.bottom = pad.bottom + "px";
        cel.style.left = pad.left + "px";
        el.style.width = "100%";
        el.style.height = "100%";
      }

      return {
        getWidth: function() { return cel.offsetWidth; },
        getHeight: function() { return cel.offsetHeight; }
      };

    } else {
      el.style.width = px(sizing.width);
      el.style.height = px(sizing.height);

      return {
        getWidth: function() { return el.offsetWidth; },
        getHeight: function() { return el.offsetHeight; }
      };
    }
  }

  // Default implementations for methods
  var defaults = {
    find: function(scope) {
      return querySelectorAll(scope, "." + this.name);
    },
    renderError: function(el, err) {
      var $el = $(el);

      this.clearError(el);

      // Add all these error classes, as Shiny does
      var errClass = "shiny-output-error";
      if (err.type !== null) {
        // use the classes of the error condition as CSS class names
        errClass = errClass + " " + $.map(asArray(err.type), function(type) {
          return errClass + "-" + type;
        }).join(" ");
      }
      errClass = errClass + " htmlwidgets-error";

      // Is el inline or block? If inline or inline-block, just display:none it
      // and add an inline error.
      var display = $el.css("display");
      $el.data("restore-display-mode", display);

      if (display === "inline" || display === "inline-block") {
        $el.hide();
        if (err.message !== "") {
          var errorSpan = $("<span>").addClass(errClass);
          errorSpan.text(err.message);
          $el.after(errorSpan);
        }
      } else if (display === "block") {
        // If block, add an error just after the el, set visibility:none on the
        // el, and position the error to be on top of the el.
        // Mark it with a unique ID and CSS class so we can remove it later.
        $el.css("visibility", "hidden");
        if (err.message !== "") {
          var errorDiv = $("<div>").addClass(errClass).css("position", "absolute")
            .css("top", el.offsetTop)
            .css("left", el.offsetLeft)
            // setting width can push out the page size, forcing otherwise
            // unnecessary scrollbars to appear and making it impossible for
            // the element to shrink; so use max-width instead
            .css("maxWidth", el.offsetWidth)
            .css("height", el.offsetHeight);
          errorDiv.text(err.message);
          $el.after(errorDiv);

          // Really dumb way to keep the size/position of the error in sync with
          // the parent element as the window is resized or whatever.
          var intId = setInterval(function() {
            if (!errorDiv[0].parentElement) {
              clearInterval(intId);
              return;
            }
            errorDiv
              .css("top", el.offsetTop)
              .css("left", el.offsetLeft)
              .css("maxWidth", el.offsetWidth)
              .css("height", el.offsetHeight);
          }, 500);
        }
      }
    },
    clearError: function(el) {
      var $el = $(el);
      var display = $el.data("restore-display-mode");
      $el.data("restore-display-mode", null);

      if (display === "inline" || display === "inline-block") {
        if (display)
          $el.css("display", display);
        $(el.nextSibling).filter(".htmlwidgets-error").remove();
      } else if (display === "block"){
        $el.css("visibility", "inherit");
        $(el.nextSibling).filter(".htmlwidgets-error").remove();
      }
    },
    sizing: {}
  };

  // Called by widget bindings to register a new type of widget. The definition
  // object can contain the following properties:
  // - name (required) - A string indicating the binding name, which will be
  //   used by default as the CSS classname to look for.
  // - initialize (optional) - A function(el) that will be called once per
  //   widget element; if a value is returned, it will be passed as the third
  //   value to renderValue.
  // - renderValue (required) - A function(el, data, initValue) that will be
  //   called with data. Static contexts will cause this to be called once per
  //   element; Shiny apps will cause this to be called multiple times per
  //   element, as the data changes.
  window.HTMLWidgets.widget = function(definition) {
    if (!definition.name) {
      throw new Error("Widget must have a name");
    }
    if (!definition.type) {
      throw new Error("Widget must have a type");
    }
    // Currently we only support output widgets
    if (definition.type !== "output") {
      throw new Error("Unrecognized widget type '" + definition.type + "'");
    }
    // TODO: Verify that .name is a valid CSS classname

    // Support new-style instance-bound definitions. Old-style class-bound
    // definitions have one widget "object" per widget per type/class of
    // widget; the renderValue and resize methods on such widget objects
    // take el and instance arguments, because the widget object can't
    // store them. New-style instance-bound definitions have one widget
    // object per widget instance; the definition that's passed in doesn't
    // provide renderValue or resize methods at all, just the single method
    //   factory(el, width, height)
    // which returns an object that has renderValue(x) and resize(w, h).
    // This enables a far more natural programming style for the widget
    // author, who can store per-instance state using either OO-style
    // instance fields or functional-style closure variables (I guess this
    // is in contrast to what can only be called C-style pseudo-OO which is
    // what we required before).
    if (definition.factory) {
      definition = createLegacyDefinitionAdapter(definition);
    }

    if (!definition.renderValue) {
      throw new Error("Widget must have a renderValue function");
    }

    // For static rendering (non-Shiny), use a simple widget registration
    // scheme. We also use this scheme for Shiny apps/documents that also
    // contain static widgets.
    window.HTMLWidgets.widgets = window.HTMLWidgets.widgets || [];
    // Merge defaults into the definition; don't mutate the original definition.
    var staticBinding = extend({}, defaults, definition);
    overrideMethod(staticBinding, "find", function(superfunc) {
      return function(scope) {
        var results = superfunc(scope);
        // Filter out Shiny outputs, we only want the static kind
        return filterByClass(results, "html-widget-output", false);
      };
    });
    window.HTMLWidgets.widgets.push(staticBinding);

    if (shinyMode) {
      // Shiny is running. Register the definition with an output binding.
      // The definition itself will not be the output binding, instead
      // we will make an output binding object that delegates to the
      // definition. This is because we foolishly used the same method
      // name (renderValue) for htmlwidgets definition and Shiny bindings
      // but they actually have quite different semantics (the Shiny
      // bindings receive data that includes lots of metadata that it
      // strips off before calling htmlwidgets renderValue). We can't
      // just ignore the difference because in some widgets it's helpful
      // to call this.renderValue() from inside of resize(), and if
      // we're not delegating, then that call will go to the Shiny
      // version instead of the htmlwidgets version.

      // Merge defaults with definition, without mutating either.
      var bindingDef = extend({}, defaults, definition);

      // This object will be our actual Shiny binding.
      var shinyBinding = new Shiny.OutputBinding();

      // With a few exceptions, we'll want to simply use the bindingDef's
      // version of methods if they are available, otherwise fall back to
      // Shiny's defaults. NOTE: If Shiny's output bindings gain additional
      // methods in the future, and we want them to be overrideable by
      // HTMLWidget binding definitions, then we'll need to add them to this
      // list.
      delegateMethod(shinyBinding, bindingDef, "getId");
      delegateMethod(shinyBinding, bindingDef, "onValueChange");
      delegateMethod(shinyBinding, bindingDef, "onValueError");
      delegateMethod(shinyBinding, bindingDef, "renderError");
      delegateMethod(shinyBinding, bindingDef, "clearError");
      delegateMethod(shinyBinding, bindingDef, "showProgress");

      // The find, renderValue, and resize are handled differently, because we
      // want to actually decorate the behavior of the bindingDef methods.

      shinyBinding.find = function(scope) {
        var results = bindingDef.find(scope);

        // Only return elements that are Shiny outputs, not static ones
        var dynamicResults = results.filter(".html-widget-output");

        // It's possible that whatever caused Shiny to think there might be
        // new dynamic outputs, also caused there to be new static outputs.
        // Since there might be lots of different htmlwidgets bindings, we
        // schedule execution for later--no need to staticRender multiple
        // times.
        if (results.length !== dynamicResults.length)
          scheduleStaticRender();

        return dynamicResults;
      };

      // Wrap renderValue to handle initialization, which unfortunately isn't
      // supported natively by Shiny at the time of this writing.

      shinyBinding.renderValue = function(el, data) {
        Shiny.renderDependencies(data.deps);
        // Resolve strings marked as javascript literals to objects
        if (!(data.evals instanceof Array)) data.evals = [data.evals];
        for (var i = 0; data.evals && i < data.evals.length; i++) {
          window.HTMLWidgets.evaluateStringMember(data.x, data.evals[i]);
        }
        if (!bindingDef.renderOnNullValue) {
          if (data.x === null) {
            el.style.visibility = "hidden";
            return;
          } else {
            el.style.visibility = "inherit";
          }
        }
        if (!elementData(el, "initialized")) {
          initSizing(el);

          elementData(el, "initialized", true);
          if (bindingDef.initialize) {
            var result = bindingDef.initialize(el, el.offsetWidth,
              el.offsetHeight);
            elementData(el, "init_result", result);
          }
        }
        bindingDef.renderValue(el, data.x, elementData(el, "init_result"));
        evalAndRun(data.jsHooks.render, elementData(el, "init_result"), [el, data.x]);
      };

      // Only override resize if bindingDef implements it
      if (bindingDef.resize) {
        shinyBinding.resize = function(el, width, height) {
          // Shiny can call resize before initialize/renderValue have been
          // called, which doesn't make sense for widgets.
          if (elementData(el, "initialized")) {
            bindingDef.resize(el, width, height, elementData(el, "init_result"));
          }
        };
      }

      Shiny.outputBindings.register(shinyBinding, bindingDef.name);
    }
  };

  var scheduleStaticRenderTimerId = null;
  function scheduleStaticRender() {
    if (!scheduleStaticRenderTimerId) {
      scheduleStaticRenderTimerId = setTimeout(function() {
        scheduleStaticRenderTimerId = null;
        window.HTMLWidgets.staticRender();
      }, 1);
    }
  }

  // Render static widgets after the document finishes loading
  // Statically render all elements that are of this widget's class
  window.HTMLWidgets.staticRender = function() {
    var bindings = window.HTMLWidgets.widgets || [];
    forEach(bindings, function(binding) {
      var matches = binding.find(document.documentElement);
      forEach(matches, function(el) {
        var sizeObj = initSizing(el, binding);

        if (hasClass(el, "html-widget-static-bound"))
          return;
        el.className = el.className + " html-widget-static-bound";

        var initResult;
        if (binding.initialize) {
          initResult = binding.initialize(el,
            sizeObj ? sizeObj.getWidth() : el.offsetWidth,
            sizeObj ? sizeObj.getHeight() : el.offsetHeight
          );
          elementData(el, "init_result", initResult);
        }

        if (binding.resize) {
          var lastSize = {
            w: sizeObj ? sizeObj.getWidth() : el.offsetWidth,
            h: sizeObj ? sizeObj.getHeight() : el.offsetHeight
          };
          var resizeHandler = function(e) {
            var size = {
              w: sizeObj ? sizeObj.getWidth() : el.offsetWidth,
              h: sizeObj ? sizeObj.getHeight() : el.offsetHeight
            };
            if (size.w === 0 && size.h === 0)
              return;
            if (size.w === lastSize.w && size.h === lastSize.h)
              return;
            lastSize = size;
            binding.resize(el, size.w, size.h, initResult);
          };

          on(window, "resize", resizeHandler);

          // This is needed for cases where we're running in a Shiny
          // app, but the widget itself is not a Shiny output, but
          // rather a simple static widget. One example of this is
          // an rmarkdown document that has runtime:shiny and widget
          // that isn't in a render function. Shiny only knows to
          // call resize handlers for Shiny outputs, not for static
          // widgets, so we do it ourselves.
          if (window.jQuery) {
            window.jQuery(document).on(
              "shown.htmlwidgets shown.bs.tab.htmlwidgets shown.bs.collapse.htmlwidgets",
              resizeHandler
            );
            window.jQuery(document).on(
              "hidden.htmlwidgets hidden.bs.tab.htmlwidgets hidden.bs.collapse.htmlwidgets",
              resizeHandler
            );
          }

          // This is needed for the specific case of ioslides, which
          // flips slides between display:none and display:block.
          // Ideally we would not have to have ioslide-specific code
          // here, but rather have ioslides raise a generic event,
          // but the rmarkdown package just went to CRAN so the
          // window to getting that fixed may be long.
          if (window.addEventListener) {
            // It's OK to limit this to window.addEventListener
            // browsers because ioslides itself only supports
            // such browsers.
            on(document, "slideenter", resizeHandler);
            on(document, "slideleave", resizeHandler);
          }
        }

        var scriptData = document.querySelector("script[data-for='" + el.id + "'][type='application/json']");
        if (scriptData) {
          var data = JSON.parse(scriptData.textContent || scriptData.text);
          // Resolve strings marked as javascript literals to objects
          if (!(data.evals instanceof Array)) data.evals = [data.evals];
          for (var k = 0; data.evals && k < data.evals.length; k++) {
            window.HTMLWidgets.evaluateStringMember(data.x, data.evals[k]);
          }
          binding.renderValue(el, data.x, initResult);
          evalAndRun(data.jsHooks.render, initResult, [el, data.x]);
        }
      });
    });

    invokePostRenderHandlers();
  }


  function has_jQuery3() {
    if (!window.jQuery) {
      return false;
    }
    var $version = window.jQuery.fn.jquery;
    var $major_version = parseInt($version.split(".")[0]);
    return $major_version >= 3;
  }

  /*
  / Shiny 1.4 bumped jQuery from 1.x to 3.x which means jQuery's
  / on-ready handler (i.e., $(fn)) is now asyncronous (i.e., it now
  / really means $(setTimeout(fn)).
  / https://jquery.com/upgrade-guide/3.0/#breaking-change-document-ready-handlers-are-now-asynchronous
  /
  / Since Shiny uses $() to schedule initShiny, shiny>=1.4 calls initShiny
  / one tick later than it did before, which means staticRender() is
  / called renderValue() earlier than (advanced) widget authors might be expecting.
  / https://github.com/rstudio/shiny/issues/2630
  /
  / For a concrete example, leaflet has some methods (e.g., updateBounds)
  / which reference Shiny methods registered in initShiny (e.g., setInputValue).
  / Since leaflet is privy to this life-cycle, it knows to use setTimeout() to
  / delay execution of those methods (until Shiny methods are ready)
  / https://github.com/rstudio/leaflet/blob/18ec981/javascript/src/index.js#L266-L268
  /
  / Ideally widget authors wouldn't need to use this setTimeout() hack that
  / leaflet uses to call Shiny methods on a staticRender(). In the long run,
  / the logic initShiny should be broken up so that method registration happens
  / right away, but binding happens later.
  */
  function maybeStaticRenderLater() {
    if (shinyMode && has_jQuery3()) {
      window.jQuery(window.HTMLWidgets.staticRender);
    } else {
      window.HTMLWidgets.staticRender();
    }
  }

  if (document.addEventListener) {
    document.addEventListener("DOMContentLoaded", function() {
      document.removeEventListener("DOMContentLoaded", arguments.callee, false);
      maybeStaticRenderLater();
    }, false);
  } else if (document.attachEvent) {
    document.attachEvent("onreadystatechange", function() {
      if (document.readyState === "complete") {
        document.detachEvent("onreadystatechange", arguments.callee);
        maybeStaticRenderLater();
      }
    });
  }


  window.HTMLWidgets.getAttachmentUrl = function(depname, key) {
    // If no key, default to the first item
    if (typeof(key) === "undefined")
      key = 1;

    var link = document.getElementById(depname + "-" + key + "-attachment");
    if (!link) {
      throw new Error("Attachment " + depname + "/" + key + " not found in document");
    }
    return link.getAttribute("href");
  };

  window.HTMLWidgets.dataframeToD3 = function(df) {
    var names = [];
    var length;
    for (var name in df) {
        if (df.hasOwnProperty(name))
            names.push(name);
        if (typeof(df[name]) !== "object" || typeof(df[name].length) === "undefined") {
            throw new Error("All fields must be arrays");
        } else if (typeof(length) !== "undefined" && length !== df[name].length) {
            throw new Error("All fields must be arrays of the same length");
        }
        length = df[name].length;
    }
    var results = [];
    var item;
    for (var row = 0; row < length; row++) {
        item = {};
        for (var col = 0; col < names.length; col++) {
            item[names[col]] = df[names[col]][row];
        }
        results.push(item);
    }
    return results;
  };

  window.HTMLWidgets.transposeArray2D = function(array) {
      if (array.length === 0) return array;
      var newArray = array[0].map(function(col, i) {
          return array.map(function(row) {
              return row[i]
          })
      });
      return newArray;
  };
  // Split value at splitChar, but allow splitChar to be escaped
  // using escapeChar. Any other characters escaped by escapeChar
  // will be included as usual (including escapeChar itself).
  function splitWithEscape(value, splitChar, escapeChar) {
    var results = [];
    var escapeMode = false;
    var currentResult = "";
    for (var pos = 0; pos < value.length; pos++) {
      if (!escapeMode) {
        if (value[pos] === splitChar) {
          results.push(currentResult);
          currentResult = "";
        } else if (value[pos] === escapeChar) {
          escapeMode = true;
        } else {
          currentResult += value[pos];
        }
      } else {
        currentResult += value[pos];
        escapeMode = false;
      }
    }
    if (currentResult !== "") {
      results.push(currentResult);
    }
    return results;
  }
  // Function authored by Yihui/JJ Allaire
  window.HTMLWidgets.evaluateStringMember = function(o, member) {
    var parts = splitWithEscape(member, '.', '\\');
    for (var i = 0, l = parts.length; i < l; i++) {
      var part = parts[i];
      // part may be a character or 'numeric' member name
      if (o !== null && typeof o === "object" && part in o) {
        if (i == (l - 1)) { // if we are at the end of the line then evalulate
          if (typeof o[part] === "string")
            o[part] = tryEval(o[part]);
        } else { // otherwise continue to next embedded object
          o = o[part];
        }
      }
    }
  };

  // Retrieve the HTMLWidget instance (i.e. the return value of an
  // HTMLWidget binding's initialize() or factory() function)
  // associated with an element, or null if none.
  window.HTMLWidgets.getInstance = function(el) {
    return elementData(el, "init_result");
  };

  // Finds the first element in the scope that matches the selector,
  // and returns the HTMLWidget instance (i.e. the return value of
  // an HTMLWidget binding's initialize() or factory() function)
  // associated with that element, if any. If no element matches the
  // selector, or the first matching element has no HTMLWidget
  // instance associated with it, then null is returned.
  //
  // The scope argument is optional, and defaults to window.document.
  window.HTMLWidgets.find = function(scope, selector) {
    if (arguments.length == 1) {
      selector = scope;
      scope = document;
    }

    var el = scope.querySelector(selector);
    if (el === null) {
      return null;
    } else {
      return window.HTMLWidgets.getInstance(el);
    }
  };

  // Finds all elements in the scope that match the selector, and
  // returns the HTMLWidget instances (i.e. the return values of
  // an HTMLWidget binding's initialize() or factory() function)
  // associated with the elements, in an array. If elements that
  // match the selector don't have an associated HTMLWidget
  // instance, the returned array will contain nulls.
  //
  // The scope argument is optional, and defaults to window.document.
  window.HTMLWidgets.findAll = function(scope, selector) {
    if (arguments.length == 1) {
      selector = scope;
      scope = document;
    }

    var nodes = scope.querySelectorAll(selector);
    var results = [];
    for (var i = 0; i < nodes.length; i++) {
      results.push(window.HTMLWidgets.getInstance(nodes[i]));
    }
    return results;
  };

  var postRenderHandlers = [];
  function invokePostRenderHandlers() {
    while (postRenderHandlers.length) {
      var handler = postRenderHandlers.shift();
      if (handler) {
        handler();
      }
    }
  }

  // Register the given callback function to be invoked after the
  // next time static widgets are rendered.
  window.HTMLWidgets.addPostRenderHandler = function(callback) {
    postRenderHandlers.push(callback);
  };

  // Takes a new-style instance-bound definition, and returns an
  // old-style class-bound definition. This saves us from having
  // to rewrite all the logic in this file to accomodate both
  // types of definitions.
  function createLegacyDefinitionAdapter(defn) {
    var result = {
      name: defn.name,
      type: defn.type,
      initialize: function(el, width, height) {
        return defn.factory(el, width, height);
      },
      renderValue: function(el, x, instance) {
        return instance.renderValue(x);
      },
      resize: function(el, width, height, instance) {
        return instance.resize(width, height);
      }
    };

    if (defn.find)
      result.find = defn.find;
    if (defn.renderError)
      result.renderError = defn.renderError;
    if (defn.clearError)
      result.clearError = defn.clearError;

    return result;
  }
})();

</script>
<script>var rough=function(){'use strict';function e(e,t){return e.type===t}function t(e){const t=e[0],i=e[1];return y(g(t[0]-i[0],2)+g(t[1]-i[1],2))}function i(e,t){const s=[],n=new A([e[0],e[1]],[e[2],e[3]]);for(let a=0;a<t.length;a++){const e=new A(t[a],t[(a+1)%t.length]);n.intersects(e)&&s.push([n.xi,n.yi])}return s}function s(e,t,i,s,n,a,l){return[-i*a-s*n+i+a*e+n*t,l*(i*n-s*a)+s+-l*n*e+l*a*t]}function n(e,t){const s=[];if(e&&e.length){let n=e[0][0],a=e[0][0],l=e[0][1],o=e[0][1];for(let t=1;t<e.length;t++)n=f(n,e[t][0]),a=d(a,e[t][0]),l=f(l,e[t][1]),o=d(o,e[t][1]);const p=t.hachureAngle;let h=t.hachureGap;0>h&&(h=4*t.strokeWidth),h=d(h,.1);const g=p%180*(m/180),c=_(g),u=b(g),y=r(g),x=new S(l-1,o+1,n-1,a+1,h,u,c,y);for(let t;null!=(t=x.nextLine());){const n=i(t,e);for(let e=0;e<n.length;e++)if(e<n.length-1){const t=n[e],i=n[e+1];s.push([t,i])}}}return s}function a(e,t,i,n,a,l){const o=[];let p=w(i/2),d=w(n/2);p+=l.getOffset(.05*-p,.05*p,a),d+=l.getOffset(.05*-d,.05*d,a);const f=a.hachureAngle;let h=a.hachureGap;0>=h&&(h=4*a.strokeWidth);let g=a.fillWeight;0>g&&(g=a.strokeWidth/2);const c=r(f%180*(m/180)),u=d/p,_=y(u*c*u*c+1),x=u*c/_,b=1/_,O=h/(p*d/y(d*b*(d*b)+p*x*(p*x))/p);let P=y(p*p-(e-p+O)*(e-p+O));for(let r=e-p+O;r<e+p;r+=O){P=y(p*p-(e-r)*(e-r));const i=s(r,t-P,e,t,x,b,u),n=s(r,t+P,e,t,x,b,u);o.push([i,n])}return o}function l(e,t){let i=t.fillStyle||'hachure';if(!E[i])switch(i){case'zigzag':E[i]||(E[i]=new C(e));break;case'cross-hatch':E[i]||(E[i]=new W(e));break;case'dots':E[i]||(E[i]=new z(e));break;case'hachure':default:i='hachure',E[i]||(E[i]=new T(e));}return E[i]}function o(e){if(L&&R&&self&&self.workly&&e.async&&!e.noWorker){const t=e.worklyURL||'https://cdn.jsdelivr.net/gh/pshihn/workly/dist/workly.min.js';if(t){const e=`importScripts('${t}', '${R}');\nworkly.expose(self.rough.createRenderer());`,i=URL.createObjectURL(new Blob([e]));return self.workly.proxy(i)}}return new N}var p=Math.round,r=Math.tan,d=Math.max,f=Math.min,h=Number.MAX_VALUE,g=Math.pow,c=Math.floor,u=Math.ceil,y=Math.sqrt,_=Math.cos,b=Math.sin,w=Math.abs,m=Math.PI;const x={A:7,a:7,C:6,c:6,H:1,h:1,L:2,l:2,M:2,m:2,Q:4,q:4,S:4,s:4,T:4,t:2,V:1,v:1,Z:0,z:0};class O{constructor(e){this.COMMAND=0,this.NUMBER=1,this.EOD=2,this.segments=[],this.parseData(e),this.processPoints()}tokenize(e){const t=[];for(;''!==e;)if(e.match(/^([ \t\r\n,]+)/))e=e.substr(RegExp.$1.length);else if(e.match(/^([aAcChHlLmMqQsStTvVzZ])/))t[t.length]={type:this.COMMAND,text:RegExp.$1},e=e.substr(RegExp.$1.length);else if(e.match(/^(([-+]?[0-9]+(\.[0-9]*)?|[-+]?\.[0-9]+)([eE][-+]?[0-9]+)?)/))t[t.length]={type:this.NUMBER,text:`${parseFloat(RegExp.$1)}`},e=e.substr(RegExp.$1.length);else return console.error('Unrecognized segment command: '+e),[];return t[t.length]={type:this.EOD,text:''},t}parseData(t){const s=this.tokenize(t);let n=0,i=s[n],a='BOD';for(this.segments=[];!e(i,this.EOD);){let l;const o=[];if(!('BOD'===a))e(i,this.NUMBER)?l=x[a]:(n++,l=x[i.text],a=i.text);else if('M'===i.text||'m'===i.text)n++,l=x[i.text],a=i.text;else return void this.parseData('M0,0'+t);if(n+l<s.length){for(let t=n;t<n+l;t++){const i=s[t];if(e(i,this.NUMBER))o[o.length]=+i.text;else return void console.error('Parameter type is not a number: '+a+','+i.text)}if('number'==typeof x[a]){const e={key:a,data:o};this.segments.push(e),n+=l,i=s[n],'M'===a&&(a='L'),'m'===a&&(a='l')}else return void console.error('Unsupported segment type: '+a)}else console.error('Path data ended before all parameters were found')}}get closed(){if('undefined'==typeof this._closed){this._closed=!1;for(const e of this.segments)'z'===e.key.toLowerCase()&&(this._closed=!0)}return this._closed}processPoints(){let e=null,t=[0,0];for(let n=0;n<this.segments.length;n++){const i=this.segments[n];switch(i.key){case'M':case'L':case'T':i.point=[i.data[0],i.data[1]];break;case'm':case'l':case't':i.point=[i.data[0]+t[0],i.data[1]+t[1]];break;case'H':i.point=[i.data[0],t[1]];break;case'h':i.point=[i.data[0]+t[0],t[1]];break;case'V':i.point=[t[0],i.data[0]];break;case'v':i.point=[t[0],i.data[0]+t[1]];break;case'z':case'Z':e&&(i.point=[e[0],e[1]]);break;case'C':i.point=[i.data[4],i.data[5]];break;case'c':i.point=[i.data[4]+t[0],i.data[5]+t[1]];break;case'S':i.point=[i.data[2],i.data[3]];break;case's':i.point=[i.data[2]+t[0],i.data[3]+t[1]];break;case'Q':i.point=[i.data[2],i.data[3]];break;case'q':i.point=[i.data[2]+t[0],i.data[3]+t[1]];break;case'A':i.point=[i.data[5],i.data[6]];break;case'a':i.point=[i.data[5]+t[0],i.data[6]+t[1]];}('m'===i.key||'M'===i.key)&&(e=null),i.point&&(t=i.point,!e&&(e=i.point)),('z'===i.key||'Z'===i.key)&&(e=null)}}}class P{constructor(e){this._position=[0,0],this._first=null,this.bezierReflectionPoint=null,this.quadReflectionPoint=null,this.parsed=new O(e)}get segments(){return this.parsed.segments}get closed(){return this.parsed.closed}get linearPoints(){if(!this._linearPoints){const e=[];let t=[];for(const i of this.parsed.segments){const s=i.key.toLowerCase();('m'===s||'z'===s)&&(t.length&&(e.push(t),t=[]),'z'===s)||i.point&&t.push(i.point)}t.length&&(e.push(t),t=[]),this._linearPoints=e}return this._linearPoints}get first(){return this._first}set first(e){this._first=e}setPosition(e,t){this._position=[e,t],this._first||(this._first=[e,t])}get position(){return this._position}get x(){return this._position[0]}get y(){return this._position[1]}}class v{constructor(e,t,i,s,n,a){if(this._segIndex=0,this._numSegs=0,this._rx=0,this._ry=0,this._sinPhi=0,this._cosPhi=0,this._C=[0,0],this._theta=0,this._delta=0,this._T=0,this._from=e,e[0]===t[0]&&e[1]===t[1])return;const l=m/180;this._rx=w(i[0]),this._ry=w(i[1]),this._sinPhi=b(s*l),this._cosPhi=_(s*l);const o=this._cosPhi*(e[0]-t[0])/2+this._sinPhi*(e[1]-t[1])/2,p=-this._sinPhi*(e[0]-t[0])/2+this._cosPhi*(e[1]-t[1])/2;let r=0;const d=this._rx*this._rx*this._ry*this._ry-this._rx*this._rx*p*p-this._ry*this._ry*o*o;if(0>d){const e=y(1-d/(this._rx*this._rx*this._ry*this._ry));this._rx*=e,this._ry*=e,r=0}else r=(n===a?-1:1)*y(d/(this._rx*this._rx*p*p+this._ry*this._ry*o*o));const f=r*this._rx*p/this._ry,h=-r*this._ry*o/this._rx;this._C=[0,0],this._C[0]=this._cosPhi*f-this._sinPhi*h+(e[0]+t[0])/2,this._C[1]=this._sinPhi*f+this._cosPhi*h+(e[1]+t[1])/2,this._theta=this.calculateVectorAngle(1,0,(o-f)/this._rx,(p-h)/this._ry);let g=this.calculateVectorAngle((o-f)/this._rx,(p-h)/this._ry,(-o-f)/this._rx,(-p-h)/this._ry);!a&&0<g?g-=2*m:a&&0>g&&(g+=2*m),this._numSegs=u(w(g/(m/2))),this._delta=g/this._numSegs,this._T=8/3*b(this._delta/4)*b(this._delta/4)/b(this._delta/2)}getNextSegment(){if(this._segIndex===this._numSegs)return null;const e=_(this._theta),t=b(this._theta),i=this._theta+this._delta,s=_(i),n=b(i),a=[this._cosPhi*this._rx*s-this._sinPhi*this._ry*n+this._C[0],this._sinPhi*this._rx*s+this._cosPhi*this._ry*n+this._C[1]],l=[this._from[0]+this._T*(-this._cosPhi*this._rx*t-this._sinPhi*this._ry*e),this._from[1]+this._T*(-this._sinPhi*this._rx*t+this._cosPhi*this._ry*e)],o=[a[0]+this._T*(this._cosPhi*this._rx*n+this._sinPhi*this._ry*s),a[1]+this._T*(this._sinPhi*this._rx*n-this._cosPhi*this._ry*s)];return this._theta=i,this._from=[a[0],a[1]],this._segIndex++,{cp1:l,cp2:o,to:a}}calculateVectorAngle(e,t,i,s){var n=Math.atan2;const a=n(t,e),l=n(s,i);return l>=a?l-a:2*m-(a-l)}}class k{constructor(e,t){this.sets=e,this.closed=t}fit(e){const t=[];for(const i of this.sets){const s=i.length;let n=c(e*s);if(5>n){if(5>=s)continue;n=5}t.push(this.reduce(i,n))}let s='';for(const n of t){for(let e=0;e<n.length;e++){const t=n[e];s+=0===e?'M'+t[0]+','+t[1]:'L'+t[0]+','+t[1]}this.closed&&(s+='z ')}return s}distance(e,t){return y(g(e[0]-t[0],2)+g(e[1]-t[1],2))}reduce(e,t){if(e.length<=t)return e;const n=e.slice(0);for(;n.length>t;){let e=-1,t=-1;for(let l=1;l<n.length-1;l++){const i=this.distance(n[l-1],n[l]),a=this.distance(n[l],n[l+1]),o=this.distance(n[l-1],n[l+1]),p=(i+a+o)/2,s=y(p*(p-i)*(p-a)*(p-o));(0>e||s<e)&&(e=s,t=l)}if(0<t)n.splice(t,1);else break}return n}}class A{constructor(e,t){this.xi=h,this.yi=h,this.px1=e[0],this.py1=e[1],this.px2=t[0],this.py2=t[1],this.a=this.py2-this.py1,this.b=this.px1-this.px2,this.c=this.px2*this.py1-this.px1*this.py2,this._undefined=0===this.a&&0===this.b&&0===this.c}isUndefined(){return this._undefined}intersects(e){if(this.isUndefined()||e.isUndefined())return!1;let t=h,i=h,s=0,n=0;const l=this.a,a=this.b,o=this.c;return(1e-5<w(a)&&(t=-l/a,s=-o/a),1e-5<w(e.b)&&(i=-e.a/e.b,n=-e.c/e.b),t===h)?i===h?-o/l==-e.c/e.a&&(this.py1>=f(e.py1,e.py2)&&this.py1<=d(e.py1,e.py2)?(this.xi=this.px1,this.yi=this.py1,!0):!!(this.py2>=f(e.py1,e.py2)&&this.py2<=d(e.py1,e.py2))&&(this.xi=this.px2,this.yi=this.py2,!0)):(this.xi=this.px1,this.yi=i*this.xi+n,!(-1e-5>(this.py1-this.yi)*(this.yi-this.py2)||-1e-5>(e.py1-this.yi)*(this.yi-e.py2))&&(!(1e-5>w(e.a))||!(-1e-5>(e.px1-this.xi)*(this.xi-e.px2)))):i===h?(this.xi=e.px1,this.yi=t*this.xi+s,!(-1e-5>(e.py1-this.yi)*(this.yi-e.py2)||-1e-5>(this.py1-this.yi)*(this.yi-this.py2))&&(!(1e-5>w(l))||!(-1e-5>(this.px1-this.xi)*(this.xi-this.px2)))):t===i?s==n&&(this.px1>=f(e.px1,e.px2)&&this.px1<=d(e.py1,e.py2)?(this.xi=this.px1,this.yi=this.py1,!0):!!(this.px2>=f(e.px1,e.px2)&&this.px2<=d(e.px1,e.px2))&&(this.xi=this.px2,this.yi=this.py2,!0)):(this.xi=(n-s)/(t-i),this.yi=t*this.xi+s,!(-1e-5>(this.px1-this.xi)*(this.xi-this.px2)||-1e-5>(e.px1-this.xi)*(this.xi-e.px2)))}}class S{constructor(e,t,i,s,n,a,l,o){this.deltaX=0,this.hGap=0,this.top=e,this.bottom=t,this.left=i,this.right=s,this.gap=n,this.sinAngle=a,this.tanAngle=o,1e-4>w(a)?this.pos=i+n:.9999<w(a)?this.pos=e+n:(this.deltaX=(t-e)*w(o),this.pos=i-w(this.deltaX),this.hGap=w(n/l),this.sLeft=new A([i,t],[i,e]),this.sRight=new A([s,t],[s,e]))}nextLine(){if(1e-4>w(this.sinAngle)){if(this.pos<this.right){const e=[this.pos,this.top,this.pos,this.bottom];return this.pos+=this.gap,e}}else if(!(.9999<w(this.sinAngle))){let e=this.pos-this.deltaX/2,t=this.pos+this.deltaX/2,i=this.bottom,n=this.top;if(this.pos<this.right+this.deltaX){for(;e<this.left&&t<this.left||e>this.right&&t>this.right;)if(this.pos+=this.hGap,e=this.pos-this.deltaX/2,t=this.pos+this.deltaX/2,this.pos>this.right+this.deltaX)return null;const a=new A([e,i],[t,n]);this.sLeft&&a.intersects(this.sLeft)&&(e=a.xi,i=a.yi),this.sRight&&a.intersects(this.sRight)&&(t=a.xi,n=a.yi),0<this.tanAngle&&(e=this.right-(e-this.left),t=this.right-(t-this.left));const s=[e,i,t,n];return this.pos+=this.hGap,s}}else if(this.pos<this.bottom){const e=[this.left,this.pos,this.right,this.pos];return this.pos+=this.gap,e}return null}}class T{constructor(e){this.renderer=e}fillPolygon(e,t){return this._fillPolygon(e,t)}fillEllipse(e,t,i,s,n){return this._fillEllipse(e,t,i,s,n)}_fillPolygon(e,t,i=!1){const s=n(e,t),a=this.renderLines(s,t,i);return{type:'fillSketch',ops:a}}_fillEllipse(e,t,i,s,n,l=!1){const o=a(e,t,i,s,n,this.renderer),p=this.renderLines(o,n,l);return{type:'fillSketch',ops:p}}renderLines(e,t,i){let s=[],n=null;for(const a of e)s=s.concat(this.renderer.doubleLine(a[0][0],a[0][1],a[1][0],a[1][1],t)),i&&n&&(s=s.concat(this.renderer.doubleLine(n[0],n[1],a[0][0],a[0][1],t))),n=a[1];return s}}class C extends T{fillPolygon(e,t){return this._fillPolygon(e,t,!0)}fillEllipse(e,t,i,s,n){return this._fillEllipse(e,t,i,s,n,!0)}}class W extends T{fillPolygon(e,t){const i=this._fillPolygon(e,t),s=Object.assign({},t,{hachureAngle:t.hachureAngle+90}),n=this._fillPolygon(e,s);return i.ops=i.ops.concat(n.ops),i}fillEllipse(e,t,i,s,n){const a=this._fillEllipse(e,t,i,s,n),l=Object.assign({},n,{hachureAngle:n.hachureAngle+90}),o=this._fillEllipse(e,t,i,s,l);return a.ops=a.ops.concat(o.ops),a}}class z{constructor(e){this.renderer=e}fillPolygon(e,t){t=Object.assign({},t,{curveStepCount:4,hachureAngle:0});const i=n(e,t);return this.dotsOnLines(i,t)}fillEllipse(e,t,i,s,n){n=Object.assign({},n,{curveStepCount:4,hachureAngle:0});const l=a(e,t,i,s,n,this.renderer);return this.dotsOnLines(l,n)}dotsOnLines(e,s){let n=[],a=s.hachureGap;0>a&&(a=4*s.strokeWidth),a=d(a,.1);let o=s.fillWeight;0>o&&(o=s.strokeWidth/2);for(const p of e){const e=t(p),i=e/a,l=u(i)-1,r=Math.atan((p[1][1]-p[0][1])/(p[1][0]-p[0][0]));for(let e=0;e<l;e++){const t=a*(e+1),i=t*b(r),l=t*_(r),d=[p[0][0]-l,p[0][1]+i],f=this.renderer.getOffset(d[0]-a/4,d[0]+a/4,s),h=this.renderer.getOffset(d[1]-a/4,d[1]+a/4,s),g=this.renderer.ellipse(f,h,o,o,s);n=n.concat(g.ops)}}return{type:'fillSketch',ops:n}}}const E={};class N{line(e,t,i,s,n){const a=this.doubleLine(e,t,i,s,n);return{type:'path',ops:a}}linearPath(e,t,s){const n=(e||[]).length;if(2<n){let a=[];for(let t=0;t<n-1;t++)a=a.concat(this.doubleLine(e[t][0],e[t][1],e[t+1][0],e[t+1][1],s));return t&&(a=a.concat(this.doubleLine(e[n-1][0],e[n-1][1],e[0][0],e[0][1],s))),{type:'path',ops:a}}return 2===n?this.line(e[0][0],e[0][1],e[1][0],e[1][1],s):{type:'path',ops:[]}}polygon(e,t){return this.linearPath(e,!0,t)}rectangle(e,t,i,s,n){return this.polygon([[e,t],[e+i,t],[e+i,t+s],[e,t+s]],n)}curve(e,t){const i=this._curveWithOffset(e,1*(1+.2*t.roughness),t),s=this._curveWithOffset(e,1.5*(1+.22*t.roughness),t);return{type:'path',ops:i.concat(s)}}ellipse(e,t,i,s,n){const a=2*m/n.curveStepCount;let l=w(i/2),o=w(s/2);l+=this.getOffset(.05*-l,.05*l,n),o+=this.getOffset(.05*-o,.05*o,n);const p=this._ellipse(a,e,t,l,o,1,a*this.getOffset(.1,this.getOffset(.4,1,n),n),n),r=this._ellipse(a,e,t,l,o,1.5,0,n);return{type:'path',ops:p.concat(r)}}arc(e,t,i,s,n,a,l,p,r){const o=e,d=t;let h=w(i/2),g=w(s/2);h+=this.getOffset(.01*-h,.01*h,r),g+=this.getOffset(.01*-g,.01*g,r);let c=n,u=a;for(;0>c;)c+=2*m,u+=2*m;u-c>2*m&&(c=0,u=2*m);const y=2*m/r.curveStepCount,x=f(y/2,(u-c)/2),O=this._arc(x,o,d,h,g,c,u,1,r),P=this._arc(x,o,d,h,g,c,u,1.5,r);let v=O.concat(P);return l&&(p?(v=v.concat(this.doubleLine(o,d,o+h*_(c),d+g*b(c),r)),v=v.concat(this.doubleLine(o,d,o+h*_(u),d+g*b(u),r))):(v.push({op:'lineTo',data:[o,d]}),v.push({op:'lineTo',data:[o+h*_(c),d+g*b(c)]}))),{type:'path',ops:v}}svgPath(e,t){e=(e||'').replace(/\n/g,' ').replace(/(-\s)/g,'-').replace('/(ss)/g',' ');let n=new P(e);if(t.simplification){const e=new k(n.linearPoints,n.closed),i=e.fit(t.simplification);n=new P(i)}let a=[];const l=n.segments||[];for(let o=0;o<l.length;o++){const e=l[o],i=0<o?l[o-1]:null,s=this._processSegment(n,e,i,t);s&&s.length&&(a=a.concat(s))}return{type:'path',ops:a}}solidFillPolygon(e,t){const s=[];if(e.length){const n=t.maxRandomnessOffset||0,a=e.length;if(2<a){s.push({op:'move',data:[e[0][0]+this.getOffset(-n,n,t),e[0][1]+this.getOffset(-n,n,t)]});for(let l=1;l<a;l++)s.push({op:'lineTo',data:[e[l][0]+this.getOffset(-n,n,t),e[l][1]+this.getOffset(-n,n,t)]})}}return{type:'fillPath',ops:s}}patternFillPolygon(e,t){const i=l(this,t);return i.fillPolygon(e,t)}patternFillEllipse(e,t,i,s,n){const a=l(this,n);return a.fillEllipse(e,t,i,s,n)}patternFillArc(e,t,i,s,n,a,l){const o=e,p=t;let r=w(i/2),d=w(s/2);r+=this.getOffset(.01*-r,.01*r,l),d+=this.getOffset(.01*-d,.01*d,l);let f=n,h=a;for(;0>f;)f+=2*m,h+=2*m;h-f>2*m&&(f=0,h=2*m);const g=(h-f)/l.curveStepCount,c=[];for(let u=f;u<=h;u+=g)c.push([o+r*_(u),p+d*b(u)]);return c.push([o+r*_(h),p+d*b(h)]),c.push([o,p]),this.patternFillPolygon(c,l)}getOffset(e,t,i){return i.roughness*(Math.random()*(t-e)+e)}doubleLine(e,t,i,s,n){const a=this._line(e,t,i,s,n,!0,!1),l=this._line(e,t,i,s,n,!0,!0);return a.concat(l)}_line(e,t,i,s,n,a,l){const o=g(e-i,2)+g(t-s,2);let p=n.maxRandomnessOffset||0;100*(p*p)>o&&(p=y(o)/10);const r=p/2,d=.2+.2*Math.random();let f=n.bowing*n.maxRandomnessOffset*(s-t)/200,h=n.bowing*n.maxRandomnessOffset*(e-i)/200;f=this.getOffset(-f,f,n),h=this.getOffset(-h,h,n);const c=[];return a&&(l?c.push({op:'move',data:[e+this.getOffset(-r,r,n),t+this.getOffset(-r,r,n)]}):c.push({op:'move',data:[e+this.getOffset(-p,p,n),t+this.getOffset(-p,p,n)]})),l?c.push({op:'bcurveTo',data:[f+e+(i-e)*d+this.getOffset(-r,r,n),h+t+(s-t)*d+this.getOffset(-r,r,n),f+e+2*(i-e)*d+this.getOffset(-r,r,n),h+t+2*(s-t)*d+this.getOffset(-r,r,n),i+this.getOffset(-r,r,n),s+this.getOffset(-r,r,n)]}):c.push({op:'bcurveTo',data:[f+e+(i-e)*d+this.getOffset(-p,p,n),h+t+(s-t)*d+this.getOffset(-p,p,n),f+e+2*(i-e)*d+this.getOffset(-p,p,n),h+t+2*(s-t)*d+this.getOffset(-p,p,n),i+this.getOffset(-p,p,n),s+this.getOffset(-p,p,n)]}),c}_curve(e,t,i){const n=e.length;let a=[];if(3<n){const l=[],o=1-i.curveTightness;a.push({op:'move',data:[e[1][0],e[1][1]]});for(let t=1;t+2<n;t++){const i=e[t];l[0]=[i[0],i[1]],l[1]=[i[0]+(o*e[t+1][0]-o*e[t-1][0])/6,i[1]+(o*e[t+1][1]-o*e[t-1][1])/6],l[2]=[e[t+1][0]+(o*e[t][0]-o*e[t+2][0])/6,e[t+1][1]+(o*e[t][1]-o*e[t+2][1])/6],l[3]=[e[t+1][0],e[t+1][1]],a.push({op:'bcurveTo',data:[l[1][0],l[1][1],l[2][0],l[2][1],l[3][0],l[3][1]]})}if(t&&2===t.length){const e=i.maxRandomnessOffset;a.push({op:'lineTo',data:[t[0]+this.getOffset(-e,e,i),t[1]+ +this.getOffset(-e,e,i)]})}}else 3===n?(a.push({op:'move',data:[e[1][0],e[1][1]]}),a.push({op:'bcurveTo',data:[e[1][0],e[1][1],e[2][0],e[2][1],e[2][0],e[2][1]]})):2===n&&(a=a.concat(this.doubleLine(e[0][0],e[0][1],e[1][0],e[1][1],i)));return a}_ellipse(e,t,i,s,n,a,l,p){const o=this.getOffset(-.5,.5,p)-m/2,r=[];r.push([this.getOffset(-a,a,p)+t+.9*s*_(o-e),this.getOffset(-a,a,p)+i+.9*n*b(o-e)]);for(let d=o;d<2*m+o-.01;d+=e)r.push([this.getOffset(-a,a,p)+t+s*_(d),this.getOffset(-a,a,p)+i+n*b(d)]);return r.push([this.getOffset(-a,a,p)+t+s*_(o+2*m+.5*l),this.getOffset(-a,a,p)+i+n*b(o+2*m+.5*l)]),r.push([this.getOffset(-a,a,p)+t+.98*s*_(o+l),this.getOffset(-a,a,p)+i+.98*n*b(o+l)]),r.push([this.getOffset(-a,a,p)+t+.9*s*_(o+.5*l),this.getOffset(-a,a,p)+i+.9*n*b(o+.5*l)]),this._curve(r,null,p)}_curveWithOffset(e,t,s){const n=[[e[0][0]+this.getOffset(-t,t,s),e[0][1]+this.getOffset(-t,t,s)],[e[0][0]+this.getOffset(-t,t,s),e[0][1]+this.getOffset(-t,t,s)]];for(let a=1;a<e.length;a++)n.push([e[a][0]+this.getOffset(-t,t,s),e[a][1]+this.getOffset(-t,t,s)]),a===e.length-1&&n.push([e[a][0]+this.getOffset(-t,t,s),e[a][1]+this.getOffset(-t,t,s)]);return this._curve(n,null,s)}_arc(e,t,i,s,n,a,l,p,r){const o=a+this.getOffset(-.1,.1,r),d=[];d.push([this.getOffset(-p,p,r)+t+.9*s*_(o-e),this.getOffset(-p,p,r)+i+.9*n*b(o-e)]);for(let f=o;f<=l;f+=e)d.push([this.getOffset(-p,p,r)+t+s*_(f),this.getOffset(-p,p,r)+i+n*b(f)]);return d.push([t+s*_(l),i+n*b(l)]),d.push([t+s*_(l),i+n*b(l)]),this._curve(d,null,r)}_bezierTo(e,t,s,n,a,l,p,r){const o=[],d=[r.maxRandomnessOffset||1,(r.maxRandomnessOffset||1)+.5];let h=[0,0];for(let f=0;2>f;f++)0===f?o.push({op:'move',data:[p.x,p.y]}):o.push({op:'move',data:[p.x+this.getOffset(-d[0],d[0],r),p.y+this.getOffset(-d[0],d[0],r)]}),h=[a+this.getOffset(-d[f],d[f],r),l+this.getOffset(-d[f],d[f],r)],o.push({op:'bcurveTo',data:[e+this.getOffset(-d[f],d[f],r),t+this.getOffset(-d[f],d[f],r),s+this.getOffset(-d[f],d[f],r),n+this.getOffset(-d[f],d[f],r),h[0],h[1]]});return p.setPosition(h[0],h[1]),o}_processSegment(e,t,i,s){let n=[];switch(t.key){case'M':case'm':{const i='m'===t.key;if(2<=t.data.length){let a=+t.data[0],l=+t.data[1];i&&(a+=e.x,l+=e.y);const o=1*(s.maxRandomnessOffset||0);a+=this.getOffset(-o,o,s),l+=this.getOffset(-o,o,s),e.setPosition(a,l),n.push({op:'move',data:[a,l]})}break}case'L':case'l':{const i='l'===t.key;if(2<=t.data.length){let a=+t.data[0],l=+t.data[1];i&&(a+=e.x,l+=e.y),n=n.concat(this.doubleLine(e.x,e.y,a,l,s)),e.setPosition(a,l)}break}case'H':case'h':{const i='h'===t.key;if(t.data.length){let a=+t.data[0];i&&(a+=e.x),n=n.concat(this.doubleLine(e.x,e.y,a,e.y,s)),e.setPosition(a,e.y)}break}case'V':case'v':{const i='v'===t.key;if(t.data.length){let a=+t.data[0];i&&(a+=e.y),n=n.concat(this.doubleLine(e.x,e.y,e.x,a,s)),e.setPosition(e.x,a)}break}case'Z':case'z':{e.first&&(n=n.concat(this.doubleLine(e.x,e.y,e.first[0],e.first[1],s)),e.setPosition(e.first[0],e.first[1]),e.first=null);break}case'C':case'c':{const i='c'===t.key;if(6<=t.data.length){let a=+t.data[0],l=+t.data[1],o=+t.data[2],p=+t.data[3],r=+t.data[4],d=+t.data[5];i&&(a+=e.x,o+=e.x,r+=e.x,l+=e.y,p+=e.y,d+=e.y);const f=this._bezierTo(a,l,o,p,r,d,e,s);n=n.concat(f),e.bezierReflectionPoint=[r+(r-o),d+(d-p)]}break}case'S':case's':{const a='s'===t.key;if(4<=t.data.length){let l=+t.data[0],o=+t.data[1],p=+t.data[2],r=+t.data[3];a&&(l+=e.x,p+=e.x,o+=e.y,r+=e.y);let d=l,f=o;const h=i?i.key:'';let g=null;('c'===h||'C'===h||'s'===h||'S'===h)&&(g=e.bezierReflectionPoint),g&&(d=g[0],f=g[1]);const c=this._bezierTo(d,f,l,o,p,r,e,s);n=n.concat(c),e.bezierReflectionPoint=[p+(p-l),r+(r-o)]}break}case'Q':case'q':{const i='q'===t.key;if(4<=t.data.length){let a=+t.data[0],l=+t.data[1],o=+t.data[2],p=+t.data[3];i&&(a+=e.x,o+=e.x,l+=e.y,p+=e.y);const r=1*(1+.2*s.roughness),d=1.5*(1+.22*s.roughness);n.push({op:'move',data:[e.x+this.getOffset(-r,r,s),e.y+this.getOffset(-r,r,s)]});let h=[o+this.getOffset(-r,r,s),p+this.getOffset(-r,r,s)];n.push({op:'qcurveTo',data:[a+this.getOffset(-r,r,s),l+this.getOffset(-r,r,s),h[0],h[1]]}),n.push({op:'move',data:[e.x+this.getOffset(-d,d,s),e.y+this.getOffset(-d,d,s)]}),h=[o+this.getOffset(-d,d,s),p+this.getOffset(-d,d,s)],n.push({op:'qcurveTo',data:[a+this.getOffset(-d,d,s),l+this.getOffset(-d,d,s),h[0],h[1]]}),e.setPosition(h[0],h[1]),e.quadReflectionPoint=[o+(o-a),p+(p-l)]}break}case'T':case't':{const a='t'===t.key;if(2<=t.data.length){let l=+t.data[0],o=+t.data[1];a&&(l+=e.x,o+=e.y);let p=l,r=o;const d=i?i.key:'';let h=null;('q'===d||'Q'===d||'t'===d||'T'===d)&&(h=e.quadReflectionPoint),h&&(p=h[0],r=h[1]);const g=1*(1+.2*s.roughness),c=1.5*(1+.22*s.roughness);n.push({op:'move',data:[e.x+this.getOffset(-g,g,s),e.y+this.getOffset(-g,g,s)]});let u=[l+this.getOffset(-g,g,s),o+this.getOffset(-g,g,s)];n.push({op:'qcurveTo',data:[p+this.getOffset(-g,g,s),r+this.getOffset(-g,g,s),u[0],u[1]]}),n.push({op:'move',data:[e.x+this.getOffset(-c,c,s),e.y+this.getOffset(-c,c,s)]}),u=[l+this.getOffset(-c,c,s),o+this.getOffset(-c,c,s)],n.push({op:'qcurveTo',data:[p+this.getOffset(-c,c,s),r+this.getOffset(-c,c,s),u[0],u[1]]}),e.setPosition(u[0],u[1]),e.quadReflectionPoint=[l+(l-p),o+(o-r)]}break}case'A':case'a':{const i='a'===t.key;if(7<=t.data.length){const a=+t.data[0],l=+t.data[1],o=+t.data[2],p=+t.data[3],r=+t.data[4];let d=+t.data[5],f=+t.data[6];if(i&&(d+=e.x,f+=e.y),d===e.x&&f===e.y)break;if(0==a||0==l)n=n.concat(this.doubleLine(e.x,e.y,d,f,s)),e.setPosition(d,f);else for(let t=0;1>t;t++){const t=new v([e.x,e.y],[d,f],[a,l],o,!!p,!!r);for(let i=t.getNextSegment();i;){const a=this._bezierTo(i.cp1[0],i.cp1[1],i.cp2[0],i.cp2[1],i.to[0],i.to[1],e,s);n=n.concat(a),i=t.getNextSegment()}}}break}default:}return n}}const L='undefined'!=typeof self,R=L&&self&&self.document&&self.document.currentScript&&self.document.currentScript.src,D='undefined'!=typeof self;class B{constructor(e,t){this.defaultOptions={maxRandomnessOffset:2,roughness:1,bowing:1,stroke:'#000',strokeWidth:1,curveTightness:0,curveStepCount:9,fill:null,fillStyle:'hachure',fillWeight:-1,hachureAngle:-41,hachureGap:-1},this.config=e||{},this.surface=t,this.renderer=o(this.config),this.config.options&&(this.defaultOptions=this._options(this.config.options))}_options(e){return e?Object.assign({},this.defaultOptions,e):this.defaultOptions}_drawable(e,t,i){return{shape:e,sets:t||[],options:i||this.defaultOptions}}get lib(){return this.renderer}getCanvasSize(){const e=e=>e&&'object'==typeof e&&e.baseVal&&e.baseVal.value?e.baseVal.value:e||100;return this.surface?[e(this.surface.width),e(this.surface.height)]:[100,100]}computePolygonSize(e){if(e.length){let t=e[0][0],s=e[0][0],n=e[0][1],a=e[0][1];for(let l=1;l<e.length;l++)t=f(t,e[l][0]),s=d(s,e[l][0]),n=f(n,e[l][1]),a=d(a,e[l][1]);return[s-t,a-n]}return[0,0]}polygonPath(e){let t='';if(e.length){t=`M${e[0][0]},${e[0][1]}`;for(let s=1;s<e.length;s++)t=`${t} L${e[s][0]},${e[s][1]}`}return t}computePathSize(e){let t=[0,0];if(D&&self.document)try{const i=self.document.createElementNS('http://www.w3.org/2000/svg','svg');i.setAttribute('width','0'),i.setAttribute('height','0');const s=self.document.createElementNS('http://www.w3.org/2000/svg','path');s.setAttribute('d',e),i.appendChild(s),self.document.body.appendChild(i);const n=s.getBBox();n&&(t[0]=n.width||0,t[1]=n.height||0),self.document.body.removeChild(i)}catch(e){}const i=this.getCanvasSize();return t[0]*t[1]||(t=i),t[0]=f(t[0],i[0]),t[1]=f(t[1],i[1]),t}line(e,t,i,s,n){const a=this._options(n);return this._drawable('line',[this.lib.line(e,t,i,s,a)],a)}rectangle(e,t,i,s,n){const a=this._options(n),l=[];if(a.fill){const n=[[e,t],[e+i,t],[e+i,t+s],[e,t+s]];'solid'===a.fillStyle?l.push(this.lib.solidFillPolygon(n,a)):l.push(this.lib.patternFillPolygon(n,a))}return l.push(this.lib.rectangle(e,t,i,s,a)),this._drawable('rectangle',l,a)}ellipse(e,t,i,s,n){const a=this._options(n),l=[];if(a.fill)if('solid'===a.fillStyle){const n=this.lib.ellipse(e,t,i,s,a);n.type='fillPath',l.push(n)}else l.push(this.lib.patternFillEllipse(e,t,i,s,a));return l.push(this.lib.ellipse(e,t,i,s,a)),this._drawable('ellipse',l,a)}circle(e,t,i,s){const n=this.ellipse(e,t,i,i,s);return n.shape='circle',n}linearPath(e,t){const i=this._options(t);return this._drawable('linearPath',[this.lib.linearPath(e,!1,i)],i)}arc(e,t,i,s,n,a,l=!1,p){const r=this._options(p),o=[];if(l&&r.fill)if('solid'===r.fillStyle){const l=this.lib.arc(e,t,i,s,n,a,!0,!1,r);l.type='fillPath',o.push(l)}else o.push(this.lib.patternFillArc(e,t,i,s,n,a,r));return o.push(this.lib.arc(e,t,i,s,n,a,l,!0,r)),this._drawable('arc',o,r)}curve(e,t){const i=this._options(t);return this._drawable('curve',[this.lib.curve(e,i)],i)}polygon(e,t){const i=this._options(t),s=[];if(i.fill)if('solid'===i.fillStyle)s.push(this.lib.solidFillPolygon(e,i));else{const t=this.computePolygonSize(e),n=[[0,0],[t[0],0],[t[0],t[1]],[0,t[1]]],a=this.lib.patternFillPolygon(n,i);a.type='path2Dpattern',a.size=t,a.path=this.polygonPath(e),s.push(a)}return s.push(this.lib.linearPath(e,!0,i)),this._drawable('polygon',s,i)}path(e,t){const i=this._options(t),s=[];if(!e)return this._drawable('path',s,i);if(i.fill)if('solid'===i.fillStyle){s.push({type:'path2Dfill',path:e,ops:[]})}else{const t=this.computePathSize(e),n=[[0,0],[t[0],0],[t[0],t[1]],[0,t[1]]],a=this.lib.patternFillPolygon(n,i);a.type='path2Dpattern',a.size=t,a.path=e,s.push(a)}return s.push(this.lib.svgPath(e,i)),this._drawable('path',s,i)}toPaths(e){const t=e.sets||[],i=e.options||this.defaultOptions,s=[];for(const n of t){let e=null;switch(n.type){case'path':e={d:this.opsToPath(n),stroke:i.stroke,strokeWidth:i.strokeWidth,fill:'none'};break;case'fillPath':e={d:this.opsToPath(n),stroke:'none',strokeWidth:0,fill:i.fill||'none'};break;case'fillSketch':e=this.fillSketch(n,i);break;case'path2Dfill':e={d:n.path||'',stroke:'none',strokeWidth:0,fill:i.fill||'none'};break;case'path2Dpattern':{const t=n.size,s={x:0,y:0,width:1,height:1,viewBox:`0 0 ${p(t[0])} ${p(t[1])}`,patternUnits:'objectBoundingBox',path:this.fillSketch(n,i)};e={d:n.path,stroke:'none',strokeWidth:0,pattern:s};break}}e&&s.push(e)}return s}fillSketch(e,t){let i=t.fillWeight;return 0>i&&(i=t.strokeWidth/2),{d:this.opsToPath(e),stroke:t.fill||'none',strokeWidth:i,fill:'none'}}opsToPath(e){let t='';for(const i of e.ops){const e=i.data;switch(i.op){case'move':t+=`M${e[0]} ${e[1]} `;break;case'bcurveTo':t+=`C${e[0]} ${e[1]}, ${e[2]} ${e[3]}, ${e[4]} ${e[5]} `;break;case'qcurveTo':t+=`Q${e[0]} ${e[1]}, ${e[2]} ${e[3]} `;break;case'lineTo':t+=`L${e[0]} ${e[1]} `;}}return t.trim()}}const M='undefined'!=typeof document;class q{constructor(e,t){this.canvas=e,this.ctx=this.canvas.getContext('2d'),this.gen=new B(t||null,this.canvas)}get generator(){return this.gen}static createRenderer(){return new N}line(e,t,i,s,n){const a=this.gen.line(e,t,i,s,n);return this.draw(a),a}rectangle(e,t,i,s,n){const a=this.gen.rectangle(e,t,i,s,n);return this.draw(a),a}ellipse(e,t,i,s,n){const a=this.gen.ellipse(e,t,i,s,n);return this.draw(a),a}circle(e,t,i,s){const n=this.gen.circle(e,t,i,s);return this.draw(n),n}linearPath(e,t){const i=this.gen.linearPath(e,t);return this.draw(i),i}polygon(e,t){const i=this.gen.polygon(e,t);return this.draw(i),i}arc(e,t,i,s,n,a,l=!1,o){const p=this.gen.arc(e,t,i,s,n,a,l,o);return this.draw(p),p}curve(e,t){const i=this.gen.curve(e,t);return this.draw(i),i}path(e,t){const i=this.gen.path(e,t);return this.draw(i),i}draw(e){const t=e.sets||[],i=e.options||this.gen.defaultOptions,s=this.ctx;for(const n of t)switch(n.type){case'path':s.save(),s.strokeStyle=i.stroke,s.lineWidth=i.strokeWidth,this._drawToContext(s,n),s.restore();break;case'fillPath':s.save(),s.fillStyle=i.fill||'',this._drawToContext(s,n),s.restore();break;case'fillSketch':this.fillSketch(s,n,i);break;case'path2Dfill':{this.ctx.save(),this.ctx.fillStyle=i.fill||'';const e=new Path2D(n.path);this.ctx.fill(e),this.ctx.restore();break}case'path2Dpattern':{if(M){const e=n.size,t=document.createElement('canvas'),s=t.getContext('2d'),a=this.computeBBox(n.path);a&&(a.width||a.height)?(t.width=this.canvas.width,t.height=this.canvas.height,s.translate(a.x||0,a.y||0)):(t.width=e[0],t.height=e[1]),this.fillSketch(s,n,i),this.ctx.save(),this.ctx.fillStyle=this.ctx.createPattern(t,'repeat');const l=new Path2D(n.path);this.ctx.fill(l),this.ctx.restore()}break}}}computeBBox(e){if(M)try{const t=document.createElementNS('http://www.w3.org/2000/svg','svg');t.setAttribute('width','0'),t.setAttribute('height','0');const i=self.document.createElementNS('http://www.w3.org/2000/svg','path');i.setAttribute('d',e),t.appendChild(i),document.body.appendChild(t);const s=i.getBBox();return document.body.removeChild(t),s}catch(e){}return null}fillSketch(e,t,i){let s=i.fillWeight;0>s&&(s=i.strokeWidth/2),e.save(),e.strokeStyle=i.fill||'',e.lineWidth=s,this._drawToContext(e,t),e.restore()}_drawToContext(e,t){e.beginPath();for(const i of t.ops){const t=i.data;switch(i.op){case'move':e.moveTo(t[0],t[1]);break;case'bcurveTo':e.bezierCurveTo(t[0],t[1],t[2],t[3],t[4],t[5]);break;case'qcurveTo':e.quadraticCurveTo(t[0],t[1],t[2],t[3]);break;case'lineTo':e.lineTo(t[0],t[1]);}}'fillPath'===t.type?e.fill():e.stroke()}}class F extends B{async line(e,t,i,s,n){const a=this._options(n);return this._drawable('line',[await this.lib.line(e,t,i,s,a)],a)}async rectangle(e,t,i,s,n){const a=this._options(n),l=[];if(a.fill){const n=[[e,t],[e+i,t],[e+i,t+s],[e,t+s]];'solid'===a.fillStyle?l.push((await this.lib.solidFillPolygon(n,a))):l.push((await this.lib.patternFillPolygon(n,a)))}return l.push((await this.lib.rectangle(e,t,i,s,a))),this._drawable('rectangle',l,a)}async ellipse(e,t,i,s,n){const a=this._options(n),l=[];if(a.fill)if('solid'===a.fillStyle){const n=await this.lib.ellipse(e,t,i,s,a);n.type='fillPath',l.push(n)}else l.push((await this.lib.patternFillEllipse(e,t,i,s,a)));return l.push((await this.lib.ellipse(e,t,i,s,a))),this._drawable('ellipse',l,a)}async circle(e,t,i,s){const n=await this.ellipse(e,t,i,i,s);return n.shape='circle',n}async linearPath(e,t){const i=this._options(t);return this._drawable('linearPath',[await this.lib.linearPath(e,!1,i)],i)}async arc(e,t,i,s,n,a,l=!1,p){const r=this._options(p),o=[];if(l&&r.fill)if('solid'===r.fillStyle){const l=await this.lib.arc(e,t,i,s,n,a,!0,!1,r);l.type='fillPath',o.push(l)}else o.push((await this.lib.patternFillArc(e,t,i,s,n,a,r)));return o.push((await this.lib.arc(e,t,i,s,n,a,l,!0,r))),this._drawable('arc',o,r)}async curve(e,t){const i=this._options(t);return this._drawable('curve',[await this.lib.curve(e,i)],i)}async polygon(e,t){const i=this._options(t),s=[];if(i.fill)if('solid'===i.fillStyle)s.push((await this.lib.solidFillPolygon(e,i)));else{const t=this.computePolygonSize(e),n=[[0,0],[t[0],0],[t[0],t[1]],[0,t[1]]],a=await this.lib.patternFillPolygon(n,i);a.type='path2Dpattern',a.size=t,a.path=this.polygonPath(e),s.push(a)}return s.push((await this.lib.linearPath(e,!0,i))),this._drawable('polygon',s,i)}async path(e,t){const i=this._options(t),s=[];if(!e)return this._drawable('path',s,i);if(i.fill)if('solid'===i.fillStyle){s.push({type:'path2Dfill',path:e,ops:[]})}else{const t=this.computePathSize(e),n=[[0,0],[t[0],0],[t[0],t[1]],[0,t[1]]],a=await this.lib.patternFillPolygon(n,i);a.type='path2Dpattern',a.size=t,a.path=e,s.push(a)}return s.push((await this.lib.svgPath(e,i))),this._drawable('path',s,i)}}class U extends q{constructor(e,t){super(e,t),this.genAsync=new F(t||null,this.canvas)}get generator(){return this.genAsync}async line(e,t,i,s,n){const a=await this.genAsync.line(e,t,i,s,n);return this.draw(a),a}async rectangle(e,t,i,s,n){const a=await this.genAsync.rectangle(e,t,i,s,n);return this.draw(a),a}async ellipse(e,t,i,s,n){const a=await this.genAsync.ellipse(e,t,i,s,n);return this.draw(a),a}async circle(e,t,i,s){const n=await this.genAsync.circle(e,t,i,s);return this.draw(n),n}async linearPath(e,t){const i=await this.genAsync.linearPath(e,t);return this.draw(i),i}async polygon(e,t){const i=await this.genAsync.polygon(e,t);return this.draw(i),i}async arc(e,t,i,s,n,a,l=!1,o){const p=await this.genAsync.arc(e,t,i,s,n,a,l,o);return this.draw(p),p}async curve(e,t){const i=await this.genAsync.curve(e,t);return this.draw(i),i}async path(e,t){const i=await this.genAsync.path(e,t);return this.draw(i),i}}const X='undefined'!=typeof document;class G{constructor(e,t){this.svg=e,this.gen=new B(t||null,this.svg)}get generator(){return this.gen}static createRenderer(){return new N}get defs(){if(X&&!this._defs){const e=this.svg.ownerDocument||document,t=e.createElementNS('http://www.w3.org/2000/svg','defs');this.svg.firstChild?this.svg.insertBefore(t,this.svg.firstChild):this.svg.appendChild(t),this._defs=t}return this._defs||null}line(e,t,i,s,n){const a=this.gen.line(e,t,i,s,n);return this.draw(a)}rectangle(e,t,i,s,n){const a=this.gen.rectangle(e,t,i,s,n);return this.draw(a)}ellipse(e,t,i,s,n){const a=this.gen.ellipse(e,t,i,s,n);return this.draw(a)}circle(e,t,i,s){const n=this.gen.circle(e,t,i,s);return this.draw(n)}linearPath(e,t){const i=this.gen.linearPath(e,t);return this.draw(i)}polygon(e,t){const i=this.gen.polygon(e,t);return this.draw(i)}arc(e,t,i,s,n,a,l=!1,o){const p=this.gen.arc(e,t,i,s,n,a,l,o);return this.draw(p)}curve(e,t){const i=this.gen.curve(e,t);return this.draw(i)}path(e,t){const i=this.gen.path(e,t);return this.draw(i)}draw(e){const t=e.sets||[],i=e.options||this.gen.defaultOptions,s=this.svg.ownerDocument||X&&document,n=s.createElementNS('http://www.w3.org/2000/svg','g');for(const a of t){let e=null;switch(a.type){case'path':{e=s.createElementNS('http://www.w3.org/2000/svg','path'),e.setAttribute('d',this.opsToPath(a)),e.style.stroke=i.stroke,e.style.strokeWidth=i.strokeWidth+'',e.style.fill='none';break}case'fillPath':{e=s.createElementNS('http://www.w3.org/2000/svg','path'),e.setAttribute('d',this.opsToPath(a)),e.style.stroke='none',e.style.strokeWidth='0',e.style.fill=i.fill;break}case'fillSketch':{e=this.fillSketch(s,a,i);break}case'path2Dfill':{e=s.createElementNS('http://www.w3.org/2000/svg','path'),e.setAttribute('d',a.path||''),e.style.stroke='none',e.style.strokeWidth='0',e.style.fill=i.fill;break}case'path2Dpattern':{const t=a.size,n=s.createElementNS('http://www.w3.org/2000/svg','pattern'),l=`rough-${c(Math.random()*(Number.MAX_SAFE_INTEGER||999999))}`;n.setAttribute('id',l),n.setAttribute('x','0'),n.setAttribute('y','0'),n.setAttribute('width','1'),n.setAttribute('height','1'),n.setAttribute('height','1'),n.setAttribute('viewBox',`0 0 ${p(t[0])} ${p(t[1])}`),n.setAttribute('patternUnits','objectBoundingBox');const o=this.fillSketch(s,a,i);n.appendChild(o),this.defs.appendChild(n),e=s.createElementNS('http://www.w3.org/2000/svg','path'),e.setAttribute('d',a.path||''),e.style.stroke='none',e.style.strokeWidth='0',e.style.fill=`url(#${l})`;break}}e&&n.appendChild(e)}return n}opsToPath(e){return this.gen.opsToPath(e)}fillSketch(e,t,i){let s=i.fillWeight;0>s&&(s=i.strokeWidth/2);const n=e.createElementNS('http://www.w3.org/2000/svg','path');return n.setAttribute('d',this.opsToPath(t)),n.style.stroke=i.fill,n.style.strokeWidth=s+'',n.style.fill='none',n}}class V extends G{constructor(e,t){super(e,t),this.genAsync=new F(t||null,this.svg)}get generator(){return this.genAsync}async line(e,t,i,s,n){const a=await this.genAsync.line(e,t,i,s,n);return this.draw(a)}async rectangle(e,t,i,s,n){const a=await this.genAsync.rectangle(e,t,i,s,n);return this.draw(a)}async ellipse(e,t,i,s,n){const a=await this.genAsync.ellipse(e,t,i,s,n);return this.draw(a)}async circle(e,t,i,s){const n=await this.genAsync.circle(e,t,i,s);return this.draw(n)}async linearPath(e,t){const i=await this.genAsync.linearPath(e,t);return this.draw(i)}async polygon(e,t){const i=await this.genAsync.polygon(e,t);return this.draw(i)}async arc(e,t,i,s,n,a,l=!1,o){const p=await this.genAsync.arc(e,t,i,s,n,a,l,o);return this.draw(p)}async curve(e,t){const i=await this.genAsync.curve(e,t);return this.draw(i)}async path(e,t){const i=await this.genAsync.path(e,t);return this.draw(i)}}var j={canvas(e,t){return t&&t.async?new U(e,t):new q(e,t)},svg(e,t){return t&&t.async?new V(e,t):new G(e,t)},createRenderer(){return q.createRenderer()},generator(e,t){return e&&e.async?new F(e,t):new B(e,t)}};return j}();
</script>
<script>function hexToRgb(hex) {
   /**
    * Convert hex strings to object {r:Int, g:Int, b:Int}.
    *
    * Used to isolate numbers for colors and converting them to Int
    * so that they can be used in `rgb(r,g,b)` and `rgba(r,g,b,a)` calls.
    *
    * @param {String} hex - A Hex color string (e.g "#FF0000")
    *
    * @return {Object} A object with Integer values for each colors
    * (e.g {r:255, g:234, b:123})
    */
  var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
  return result ? {
    r: parseInt(result[1], 16),
    g: parseInt(result[2], 16),
    b: parseInt(result[3], 16)
  } : null;
}


function getHachureAngle(angle, angle_noise) {
  /**
   * Calculate an angle for hachure modifying variable angle with angle_noise.
   *
   * angle_noise is a value between 0 and 1, equivalent to the percentage of
   * possible deviation from the set angle. An angle_noise of 1 means
   * that deviation up to 90 degrees are allowed.
   *
   * @param {Number} angle - the angle of hachure
   * @param {Number} angle_noise - the % of 90° variation allowed around angle
   *
   * @return {Number} a hachure angle.
   */
  let max_angle = angle_noise < 1 ? 90 * angle_noise / 2 : 90 * 1 / 2;
  let plusOrMinus = Math.random() < 0.5 ? -1 : 1;
  return angle + plusOrMinus * Math.random() * max_angle;
}

function getHachureGap(gap, gap_noise) {
  /**
   * Calculate a hachure gap, modifying variable gap with gap_noise.
   *
   * gap_noise is a value between 0 and 1, equivalent to the percentage of
   * possible deviation from the set gap. A gap_noise of 1 means
   * that deviation up to 2*gap are allowed.
   *
   * @param {Number} gap - the gap of hachure
   * @param {Number} gap_noise - the % of variation allowed around gap
   *
   * @return {Number} a hachure gap.
   */
  let max_gap = gap_noise < 1 ? gap * gap_noise : gap;
  let plusOrMinus = Math.random() < 0.5 ? -1 : 1;
  return gap + plusOrMinus * Math.random() * max_gap;
}

function getFillRGB(style, alphaOver) {
  /**
   * Parse svg style attributes to create a `rgba(r,g,b,a)` string for fill.
   *
   * When there is no set `fill-opacity` attribute, 1 (100%) is used.
   *
   * @param {Object} style - The style attributes from a svg element
   *
   * @return {String} A "rgba" string (e.g "rgba(255, 166, 34, 0.2)")
   */
  let fill = undefined;
  let opacity = 1 / alphaOver;
  if (style !== null && typeof style === 'object' && "fill" in style) {
    let {r, g, b} = hexToRgb(style.fill);
    if ("fill-opacity" in style) {
      opacity = Number(style["fill-opacity"]) / alphaOver
    }
    fill = "rgba(" + r + "," + g + "," + b + "," + opacity +")";
  }
  return fill
}

function getFillObject(s) {
  /**
   * Create an object with all roughjs options for fill.
   *
   * There is a lot more than just the fill color to set: fillStyle (hachure vs
   * solid), fillWeight, angle, gap... See https://github.com/pshihn/rough/wiki
   * This method also permit to use angle_noise via getHachureAngle,
   * which calculate the angle value dynamically around the set angle.
   *
   * @return {Object} Object of roughjs options related to fill.
   * (e.g {fillStyle:..., hachureAngle:..., hachureGap:..., ...})
   *
   */
  let fillOptions = {};
  let {angle, angle_noise, gap, gap_noise} = s.rough_options;
  let {fill_weight, fill_style, alpha_over} = s.rough_options;
  if ("fill" in s.style) {
    fillOptions = {...fillOptions, ...{
      fill: getFillRGB(s.style, alpha_over),
      fillStyle: fill_style
    }};
    if (fill_style !== "solid") {
      fillOptions = {
        ...fillOptions,
        ...{
          fillWeight: fill_weight,
          hachureGap: getHachureGap(gap, gap_noise)
        }};
    }
    if (fill_style === "dots") {
      // Anything else than 1 seems to modify the position
      fillOptions = {...fillOptions, ...{roughness: 1}};
    }
    if (fill_style !== "solid" && fill_style !== "dots") {
      let hachureOptions = {
          hachureAngle: getHachureAngle(angle, angle_noise)
      };
      fillOptions = {...fillOptions, ...hachureOptions};
    }
  }
  return fillOptions;
}

function getStrokeRGB(style) {
  /**
   * Parse svg style attributes to create a `rgba(r,g,b,a)` string for stroke.
   *
   * When there is no set `stroke-opacity` attribute, 1 (100%) is used.
   *
   * @param {Object} style - The style attributes from a svg element
   *
   * @return {String} A "rgba" string (e.g "rgba(255, 166, 34, 0.2)")
   */
  let stroke = "rgba(255,255,255,0)";
  if (style !== null && typeof style === 'object' && "stroke" in style &&
    !(style.stroke == "none" || Number(style["stroke-width"]) == 0)) {
    let {r, g, b} = hexToRgb(style.stroke);
    opacity = "stroke-opacity" in style ? Number(style["stroke-opacity"]) : 1;
    stroke = "rgba(" + r + "," + g + "," + b + "," + opacity + ")";
  }
  return stroke
}

// Only pass style?
function getStrokeObject(s) {
  /**
   * Create an object with all roughjs options for stroke.
   *
   * @return {Object} Object of roughjs options related to stroke.
   * (e.g {stroke:..., strokeWidth:...})
   *
   */
  let strokeOptions = {};
  let stroke = s.style ? getStrokeRGB(s.style) : "rgba(255,255,255,0)";
  let strokeWidth = Number(s.style["stroke-width"]);
  strokeOptions =  {
    stroke: stroke,
    strokeWidth: strokeWidth,
  }
  return strokeOptions
}

function drawRect(rc, s) {
  /**
   * Draw rectangles
   *
   * Draw rectangles on rough canvas (rc)
   *
   * @param {Object} rc - Rough Canvas
   * @param {Object} s - Shape object coming from R
   *
   * @return {} Draw rectangle on rough canvas (rc)
   */
  let options = {
    bowing: s.rough_options.bowing,
    roughness: s.rough_options.roughness
  }
  options = {...options, ...getStrokeObject(s)};
  options = {...options, ...getFillObject(s)};

  for (i = 0; i < s.rough_options.alpha_over ; i++) {
    rc.rectangle(
      Number(s.x), Number(s.y), Number(s.width), Number(s.height),
      options);
  }
}

function drawCircle(rc, s) {
  /**
   * Draw circles
   *
   * Draw circles on rough canvas (rc)
   *
   * @param {Object} rc - Rough Canvas
   * @param {Object} s - Shape object coming from R
   *
   * @return {} Draw circle on rough canvas (rc)
   */
  let options = {
    bowing: s.rough_options.bowing,
    roughness: s.rough_options.roughness
  }
  options = {...options, ...getStrokeObject(s)};
  options = {...options, ...getFillObject(s)};

  rc.circle(
    Number(s.cx), Number(s.cy), Number(s.r.slice(0,-2))*4,
    options);
}



function drawLinearPath(rc, s) {
  /**
   * Draw non-closed lines
   *
   * Points for linearPath need to be given in an array of arrays:
   * [[x,y],[x,y],[x,y]...]. We get them from R as a space/comma separated
   * string: "x,y x,y x,y x,y ...".
   *
   * The lines that we don't want to draw (i.e the ones that were set to
   * element_blank() or alpha=0 in ggplot2) should come
   * with s.style.stroke === "none", so we exclude them from the drawing.
   *
   * @param {Object} rc - Rough Canvas
   * @param {Object} s - Shape object coming from R
   *
   * @return {} Draw linear Path on rough canvas (rc)
   */
  let pointsArrayStr = s.points.split(" ").map(x => x.split(","));
  let pointsArray = pointsArrayStr.map(x => x.map(y => Number(y)));

  let options = {
    bowing: s.rough_options.bowing,
    roughness: s.rough_options.roughness
  }
  options = {...options, ...getStrokeObject(s)};

  if (s.style.stroke !== "none") {
    rc.linearPath(pointsArray, options);
  }
}


function drawPath(rc, s) {
  /**
   * Draw closed lines (and fill if needed)
   *
   * Points for `path` need to come as a string "M...points...Z". The conversion
   * is done in R.
   *
   * @param {Object} rc - Rough Canvas
   * @param {Object} s - Shape object coming from R
   *
   * @return {} Draw closed path on rough canvas (rc)
   */
  let options = {
    bowing: s.rough_options.bowing,
    roughness: s.rough_options.roughness
  }
  options = {...options, ...getStrokeObject(s)};
  options = {...options, ...getFillObject(s)};

  rc.path(s.points, options);
}

function drawText(rc, s, ctx, font) {
  /**
   * Draw Text
   *
   * Rotated text comes from svg with a `transform` attribute in the shape
   * object rather than x and y. We need to extract the x and y, as well as
   * the orientation of the rotation (clock-wise vs counterclock-wise).
   *
   * Note that text is not rendered with a roughjs function but simply with
   * basic canvas functions.
   *
   * @param {Object} rc - Rough Canvas
   * @param {Object} s - Shape object coming from R
   * @param {Object} ctx - Canvas context object
   * @param {String} font - Optional font to override the one from the shape
   *
   * @return {} Draw text
   */
  let fontSize = Number(s.style["font-size"].slice(0,-2))
  if(font === undefined) {
    ctx.font =  fontSize + "px " + s.style["font-family"]
  } else {
    ctx.font = fontSize + "px " + font;
  }
  if("font-weight" in s) {ctx.font = s["font-weight"] + " " + ctx.font;}
  ctx.fillStyle = "fill" in s.style ? s.style.fill : "#000000";
  if("transform" in s) {
    console.log("YESSSS");
    let newc = s.transform.match(/\(([^)]+)\)/)[1].split(",").map(Number)
    let rotation = Number(s.transform.match(/rotate\((.*)\)/)[1]);
    ctx.save();
    ctx.translate(newc[0], newc[1]);
    if (rotation < 0) {
      ctx.rotate(-Math.PI/2);
    } else {
      ctx.rotate(Math.PI/2);
    }
    ctx.fillText(s.content, Number(0), Number(0));
    ctx.restore();
  } else {
    ctx.fillText(s.content, Number(s.x), Number(s.y));
  }
}


HTMLWidgets.widget({

  name: 'ggrough',

  type: 'output',

  factory: function(el, width, height) {

    return {
      renderValue: function(x) {

        // Create Canvas element in DOM
        var canvas = document.createElement("canvas");
        canvas.setAttribute("id", "canvas");
        canvas.setAttribute("width", width);
        canvas.setAttribute("height", height);
        el.appendChild(canvas);

        // Insert rough canvas in the new canvas element
        const rc = rough.canvas(document.getElementById("canvas"));

        // Create context for text shape
        const c = document.getElementById("canvas");
        var ctx = c.getContext("2d");

        x.data.map(function(s) {
          if (s.shape === "rect" && !(Array.isArray(s.style))) {
            drawRect(rc, s);
          }
          if (s.shape === "circle" && !(Array.isArray(s.style))) {
            drawCircle(rc, s);
          }
          if (s.shape === "path" && !(Array.isArray(s.style))) {
            drawPath(rc, s);
          }
          if (s.shape === "linearPath" && !(Array.isArray(s.style))) {
            drawLinearPath(rc, s);
          }
          if (s.shape === "text" && !(Array.isArray(s.style))) {
            drawText(rc, s, ctx);
          }
        })
      },
      resize: function(width, height) {
        // TODO: Find a way to redraw the image on resize.
      }
    }
  }
});
</script>

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>


<style type="text/css">code{white-space: pre;}</style>
<style type="text/css" data-origin="pandoc">
code.sourceCode > span { display: inline-block; line-height: 1.25; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */

</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    for (var j = 0; j < rules.length; j++) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") continue;
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') continue;
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>



<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">Quantitive Data Humanism with Pokemon</h1>
<h4 class="author">Nik Bear Brown</h4>
<h4 class="date">Mini-Project One, October 25</h4>


<div id="quantitive-data-humanism-qdh-with-pokemon" class="section level2">
<h2>Quantitive Data Humanism (QDH) with Pokemon</h2>
<p>In this project I will explore extending the “data humanism” of Giorgia Lupi which is a reaction against the computer-generated, harsh-toned bar graphs, pie charts that tend to diminish rather than peak interest in a visualization. Giorgia Lupi describes data humanism in her manifesto <a href="http://giorgialupi.com/data-humanism-my-manifesto-for-a-new-data-wold">Data Humanism, The Revolution will be Visualized</a></p>
<p><img style="margin:40px 0 20px 0;" src="https://raw.githubusercontent.com/nikbearbrown/Google_Colab/master/QDH/graphs/GL_Data_Humanism.png" />
<p>Image credit: <a href="http://giorgialupi.com/">giorgialupi.com</a></p>
</div>
<div id="quantitive-data-humanism-qdh" class="section level2">
<h2>Quantitive Data Humanism (QDH)</h2>
<p>The “noise” in the sketchy style of can be used to convey important information in a graph. In particular, it naturally fits with representing uncertainty.</p>
<p>This article is an attempt to play with mapping the rough “sketchiness” of data humanism to common charts, like bar charts and bubble charts, where the quantitative display of uncertainty is usually not shown, often because the it is not obvious how to visually display uncertainty in many charts.</p>
<p><img style="margin:40px 0 20px 0;" src="https://raw.githubusercontent.com/nikbearbrown/Google_Colab/master/QDH/graphs/QDH_Banner.png"/>
</div>
<div id="pokemon-data-from-kaggle" class="section level2">
<h2>Pokemon Data from Kaggle</h2>
<p>I am using the Pokemon data from Kaggle becuase it is fun <a href="https://www.kaggle.com/rounakbanik/pokemon">https://www.kaggle.com/rounakbanik/pokemon</a></p>
<p>This dataset contains information on all 802 Pokemon from all Seven Generations of Pokemon. The information contained in this dataset include Base Stats, Performance against Other Types, Height, Weight, Classification, Egg Steps, Experience Points, Abilities, etc. The information was scraped from <a href="http://serebii.net">https://serebii.net/</a></p>
</div>
<div id="using-ggrough-to-create-a-sketchy-humanisitic-style" class="section level2">
<h2>Using <code>ggrough</code> to create a sketchy humanisitic style</h2>
<p>I will use the library ggrough to convert ggplot charts into a humanistic style. Note that this library was last updated years ago and has many bugs. It seems abandoned. It is an important library and needs to be rewritten and updated. A python version also needs to be created.</p>
<p><code>ggrough</code> is an R package that converts your <a href="http://ggplot2.tidyverse.org"><code>ggplot2</code></a> plots to rough/sketchy charts, using the excellent javascript <a href="http://roughjs.com"><code>roughjs</code></a> library.</p>
<p>In this article, I will only show one example of its common use as it involves just adding a couple of lines of code after a ggplot2 graph is created. To show how it was used to create all of the graphs shown is beyond the scope of this article.</p>
</div>
<div id="how-to-install" class="section level2">
<h2>How to Install</h2>
<p>One needs to use <code>devtools</code> to install <code>ggrough</code></p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1"></a><span class="kw">install.packages</span>(<span class="st">&quot;devtools&quot;</span>) <span class="co"># if you have not installed &quot;devtools&quot; package</span></span>
<span id="cb1-2"><a href="#cb1-2"></a>devtools<span class="op">::</span><span class="kw">install_github</span>(<span class="st">&quot;xvrdm/ggrough&quot;</span>)</span></code></pre></div>
<p>The other packages can be installed using <code>install.packages</code>.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1"></a><span class="kw">install.packages</span>(<span class="kw">c</span>(<span class="st">&quot;ggplot2&quot;</span>, <span class="st">&quot;dplyr&quot;</span>, <span class="st">&quot;showtext&quot;</span>,<span class="st">&quot;scales&quot;</span>))</span></code></pre></div>
</div>
<div id="playful-kids-color-scheme" class="section level2">
<h2>Playful Kids Color Scheme</h2>
<p>I want to play with playful “kids art” style colors, but don’t want to rewrite the code in order to make changes, so I created a color swatch.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1"></a>colorsKids &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;#9B1E33&quot;</span>, <span class="st">&quot;#EEBD00&quot;</span>, <span class="st">&quot;#6A953F&quot;</span>, <span class="st">&quot;#9A6233&quot;</span>, <span class="st">&quot;#69359C&quot;</span>, <span class="st">&quot;#F7B0BE&quot;</span>)</span>
<span id="cb3-2"><a href="#cb3-2"></a><span class="kw">show_col</span>(colorsKids, <span class="dt">labels =</span> F, <span class="dt">borders =</span> <span class="ot">NA</span>)</span></code></pre></div>
<p><img src="https://raw.githubusercontent.com/nikbearbrown/Google_Colab/master/QDH/graphs/colorsKids.png" />
</div>
<div id="loading-the-pokemon-data" class="section level2">
<h2>Loading the Pokemon Data</h2>
<p>The Pokemon data has a nice mix of categorical, continuous and Boolean data so many standard charts can be created. I will extend this data set with some time-series, uncertainty information and image data in the future to create a standard data set for all kinds of QDH visualization.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1"></a><span class="kw">set.seed</span>(<span class="dv">5</span>)</span>
<span id="cb4-2"><a href="#cb4-2"></a>pokemon &lt;-<span class="st"> </span><span class="kw">read.csv</span>(<span class="st">&quot;data/Pokemon.csv&quot;</span>)</span>
<span id="cb4-3"><a href="#cb4-3"></a></span>
<span id="cb4-4"><a href="#cb4-4"></a>pokemon <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">head</span>(<span class="dv">5</span>)</span></code></pre></div>
<pre><code>##   X.                  Name Type.1 Type.2 Total HP Attack Defense Sp..Atk
## 1  1             Bulbasaur  Grass Poison   318 45     49      49      65
## 2  2               Ivysaur  Grass Poison   405 60     62      63      80
## 3  3              Venusaur  Grass Poison   525 80     82      83     100
## 4  3 VenusaurMega Venusaur  Grass Poison   625 80    100     123     122
## 5  4            Charmander   Fire          309 39     52      43      60
##   Sp..Def Speed Generation Legendary
## 1      65    45          1     False
## 2      80    60          1     False
## 3     100    80          1     False
## 4     120    80          1     False
## 5      50    65          1     False</code></pre>
</div>
<div id="a-simple-histogram-example" class="section level2">
<h2>A Simple Histogram Example</h2>
<p>I will use a histogram to show how a simple computer-generated, harsh-toned graph can be converted into a playful humanistic style where the roughness and sketchiness of the graph is quantitatively determined by parameters. From here on when I use code to create humanistic graphs whose roughness and sketchiness is determined by parameters I will refer to this as Quantitive Data Humanism or QDH.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1"></a><span class="co"># Classic ggplot part</span></span>
<span id="cb6-2"><a href="#cb6-2"></a>g1&lt;-<span class="st"> </span>pokemon <span class="op">%&gt;%</span><span class="st"> </span></span>
<span id="cb6-3"><a href="#cb6-3"></a><span class="st">  </span><span class="kw">ggplot</span>(<span class="kw">aes</span>(<span class="dt">x =</span> Attack)) <span class="op">+</span></span>
<span id="cb6-4"><a href="#cb6-4"></a><span class="st">  </span><span class="kw">geom_histogram</span>(<span class="dt">bins =</span> <span class="dv">22</span>, <span class="dt">fill =</span> colorsKids[<span class="dv">5</span>], <span class="dt">alpha =</span> <span class="fl">0.6</span>, <span class="dt">color =</span> <span class="st">&quot;grey35&quot;</span>) <span class="op">+</span></span>
<span id="cb6-5"><a href="#cb6-5"></a><span class="st">  </span><span class="kw">ggtitle</span>(<span class="st">&quot;Pokemon Attack Distribution&quot;</span>) <span class="op">+</span></span>
<span id="cb6-6"><a href="#cb6-6"></a><span class="st">  </span><span class="kw">xlab</span>(<span class="st">&quot;Pokemon Attack&quot;</span>) <span class="op">+</span><span class="st">  </span></span>
<span id="cb6-7"><a href="#cb6-7"></a><span class="st">  </span><span class="kw">ylab</span>(<span class="st">&quot;Pokemon Attack Count&quot;</span>)   </span>
<span id="cb6-8"><a href="#cb6-8"></a>g1</span></code></pre></div>
<p><img src="https://raw.githubusercontent.com/nikbearbrown/Google_Colab/master/QDH/graphs/Simple_Histogram_Example.png" />

<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1"></a><span class="co"># ggsave(file=&quot;g1_QDH.svg&quot;)</span></span></code></pre></div>
<p><em>This graph shows that nearly all Pokemon have HP around the mean but there are some with massive HP</em></p>
</div>
<div id="handwritten-tyepfaces-using-showtext-and-google-fonts" class="section level2">
<h2>Handwritten Tyepfaces Using <em>showtext</em> and Google Fonts</h2>
<p>From a design perspective using handwritten tyepfaces with sketchy graphs tends to work better so we will show how to do this. For this we will use <em>Google fonts</em>.</p>
<p>To use Google fonts, try the fantastic <a href="https://github.com/yixuan/showtext"><code>showtext</code></a> package.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1"></a><span class="co">## Loading Google fonts (https://fonts.google.com/)</span></span>
<span id="cb8-2"><a href="#cb8-2"></a><span class="kw">font_add_google</span>(<span class="st">&quot;Gochi Hand&quot;</span>, <span class="st">&quot;gochi&quot;</span>)</span>
<span id="cb8-3"><a href="#cb8-3"></a><span class="co">## Automatically use showtext to render text</span></span>
<span id="cb8-4"><a href="#cb8-4"></a><span class="kw">showtext_auto</span>()</span>
<span id="cb8-5"><a href="#cb8-5"></a><span class="co"># Classic ggplot part</span></span>
<span id="cb8-6"><a href="#cb8-6"></a>g2 &lt;-<span class="st"> </span>pokemon <span class="op">%&gt;%</span><span class="st"> </span></span>
<span id="cb8-7"><a href="#cb8-7"></a><span class="st">  </span><span class="kw">ggplot</span>(<span class="kw">aes</span>(<span class="dt">x =</span> Attack)) <span class="op">+</span></span>
<span id="cb8-8"><a href="#cb8-8"></a><span class="st">  </span><span class="kw">geom_histogram</span>(<span class="dt">bins =</span> <span class="dv">22</span>, <span class="dt">fill =</span> colorsKids[<span class="dv">5</span>], <span class="dt">alpha =</span> <span class="fl">0.6</span>, <span class="dt">color =</span> <span class="st">&quot;grey35&quot;</span>) <span class="op">+</span></span>
<span id="cb8-9"><a href="#cb8-9"></a><span class="st">  </span><span class="kw">ggtitle</span>(<span class="st">&quot;Pokemon Attack Distribution&quot;</span>) <span class="op">+</span></span>
<span id="cb8-10"><a href="#cb8-10"></a><span class="st">  </span><span class="kw">xlab</span>(<span class="st">&quot;Pokemon Attack&quot;</span>) <span class="op">+</span><span class="st">  </span></span>
<span id="cb8-11"><a href="#cb8-11"></a><span class="st">  </span><span class="kw">ylab</span>(<span class="st">&quot;Pokemon Attack Count&quot;</span>)  <span class="op">+</span></span>
<span id="cb8-12"><a href="#cb8-12"></a><span class="st"> </span><span class="kw">theme</span>(</span>
<span id="cb8-13"><a href="#cb8-13"></a><span class="dt">plot.title =</span> <span class="kw">element_text</span>(<span class="dt">family =</span> <span class="st">&quot;gochi&quot;</span>, <span class="dt">size=</span><span class="dv">14</span>, <span class="dt">face=</span><span class="st">&quot;bold.italic&quot;</span>),</span>
<span id="cb8-14"><a href="#cb8-14"></a><span class="dt">axis.title.x =</span> <span class="kw">element_text</span>(<span class="dt">family =</span> <span class="st">&quot;gochi&quot;</span>, <span class="dt">size=</span><span class="dv">14</span>, <span class="dt">face=</span><span class="st">&quot;bold&quot;</span>),</span>
<span id="cb8-15"><a href="#cb8-15"></a><span class="dt">axis.title.y =</span> <span class="kw">element_text</span>(<span class="dt">family =</span> <span class="st">&quot;gochi&quot;</span>, <span class="dt">size=</span><span class="dv">14</span>, <span class="dt">face=</span><span class="st">&quot;bold&quot;</span>)</span>
<span id="cb8-16"><a href="#cb8-16"></a>)  </span>
<span id="cb8-17"><a href="#cb8-17"></a>g2</span></code></pre></div>
<p><img src="https://raw.githubusercontent.com/nikbearbrown/Google_Colab/master/QDH/graphs/Google_Fonts.png" />
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1"></a><span class="co"># ggsave(file=&quot;g2_QDH.svg&quot;)</span></span></code></pre></div>
<p><em>Handwritten Fonts already add a fun aspect to a graph</em></p>
<p><img style="margin:40px 0 20px 0;" src="https://raw.githubusercontent.com/nikbearbrown/Google_Colab/master/QDH/graphs/QDH_Google_Font.png" />
</div>
<div id="sketchy-style-with-ggrough" class="section level2">
<h2>Sketchy Style with ggRough</h2>
<p>Note that <code>ggRough</code> is a broken library with many bugs that needs to be rewritten. In theory, and after the library is rewritten, it will work as below. In practice, generating all of the graphs shown in this article is more complicated and beyond this articles scope. After this only the <code>ggplot2</code> portion of the Pokemon graph code will be shown.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1"></a><span class="co"># ggRough part</span></span>
<span id="cb10-2"><a href="#cb10-2"></a>options &lt;-<span class="st"> </span><span class="kw">list</span>(</span>
<span id="cb10-3"><a href="#cb10-3"></a>  <span class="dt">Background=</span><span class="kw">list</span>(<span class="dt">roughness=</span><span class="dv">4</span>),</span>
<span id="cb10-4"><a href="#cb10-4"></a>  <span class="dt">GeomCol=</span><span class="kw">list</span>(<span class="dt">fill_style=</span><span class="st">&quot;hachure&quot;</span>,<span class="dt">fill_weight=</span><span class="dv">2</span>, <span class="dt">angle=</span><span class="dv">60</span>,<span class="dt">angle_noise=</span><span class="fl">0.1</span>, <span class="dt">bowing=</span><span class="dv">0</span>, <span class="dt">roughness=</span><span class="dv">6</span>))</span>
<span id="cb10-5"><a href="#cb10-5"></a></span>
<span id="cb10-6"><a href="#cb10-6"></a></span>
<span id="cb10-7"><a href="#cb10-7"></a><span class="kw">get_rough_chart</span>(g2, options)</span></code></pre></div>
<p><em>A couple lines of code can add a humanistic style to a graph</em></p>
<p><img style="margin:40px 0 20px 0;" src=""https://raw.githubusercontent.com/nikbearbrown/Google_Colab/master/QDH/graphs/Sketchy_Histogram_Example.png" />
<p>I will use the following parameters to extend ggpolt plots with varying degrees of sketchiness.</p>
<div id="fill-style-fill_style" class="section level3">
<h3>Fill Style — <code>fill_style</code></h3>
<p>Categorical variable with the following values: <em>solid</em>, <em>hachure</em>, <em>cross,hatch</em>, <em>zigzag</em>, and <em>dots</em>.</p>
<p>The default is <em>solid</em>.</p>
</div>
<div id="fill-weight-fill_weight" class="section level3">
<h3>Fill Weight — <code>fill_weight</code></h3>
<p>Continuous positive variable that reflects how densely a color of applied. Think of one coat of paint rather than 5 coats of paint.</p>
<p>The default is <code>4</code>.</p>
</div>
<div id="roughness-roughness" class="section level3">
<h3>Roughness — <code>roughness</code></h3>
<p>Continuous positive variable that reflects how rough the element should be.</p>
<p>The default is <code>1.5</code>.</p>
</div>
</div>
<div id="bowing-bowing" class="section level2">
<h2>Bowing — <code>bowing</code></h2>
<p>Continuous positive variable that reflects how much the axis are bowed.</p>
<p>The default is <code>1</code>.</p>
</div>
<div id="gap-gap" class="section level2">
<h2>Gap — <code>gap</code></h2>
<p>Continuous positive variable that reflects the gap between each hachure line.</p>
<p>The default is <code>6</code>.</p>
</div>
<div id="gap-noise-gap_noise" class="section level2">
<h2>Gap Noise — <code>gap_noise</code></h2>
<p>A percentage of noise to apply on the <code>gap</code> value. Use a value between <code>0</code> and <code>1</code>. A <code>gap_noise</code> of <code>1</code> means that deviation up to <code>2 * gap</code> are allowed.</p>
<p>The default is <code>0</code>.</p>
</div>
<div id="angle-angle" class="section level2">
<h2>Angle — <code>angle</code></h2>
<p>The angle in degrees of the hachure lines ranging from <code>0</code> and <code>360</code> degrees.</p>
</div>
<div id="angle-noise-angle_noise" class="section level2">
<h2>Angle Noise — <code>angle_noise</code></h2>
<p>The <code>angle_noise</code> is a value between <code>0</code> and <code>1</code>, equivalent to the percentage of possible deviation from the set <code>angle</code>. An <code>angle_noise</code> of <code>1</code> means that deviation up to <code>90°</code> are allowed.</p>
<p>The default is <code>0</code>.</p>
<p><img style="margin:40px 0 20px 0;" src="https://raw.githubusercontent.com/nikbearbrown/Google_Colab/master/QDH/graphs/QDH_Paramters.png" />
</div>
<div id="gallery" class="section level2">
<h2>Gallery</h2>
<p>For the rest of this article I will show the effect of the parameters on common EDA graphs and not the code details of how the graphs where created. The toolset needs to be updated, refactored and rebuilt in order to make it easy for data visualization in R and python to manipulate the following parameters: fill_style, fill_weight, roughness, bowing, gap, gap_noise, angle, and angle_noise. Potentially many other parameters could be added. In 1984, Cleveland and his colleague Robert McGill published the seminal paper that created a general hierarchy for the types of data people most accurately understand:</p>
<ul>
<li>Position along a common scale (bar chart, dot plots)<br />
</li>
<li>Positions along nonaligned, identical scales (small multiples)<br />
</li>
<li>Length, direction, angle (pie chart)<br />
</li>
<li>Area (treemap)<br />
</li>
<li>Volume, curvature (3-D bar charts, area charts)<br />
</li>
<li>Shading, color saturation (heat maps, choropleth maps)</li>
</ul>
<p>Creating QDH libraries for R and python allow designers much more control over shading, color saturation, angle, etc.. This would allow designers to more easily explore which types of graphical elements convey the most information to humans.</p>
<p>See <a href="https://www.jstor.org/stable/2288400">Graphical Perception: Theory, Experimentation, and Application to the Development of Graphical Methods William S. Cleveland and Robert McGill</a></p>
<p><img style="margin:40px 0 20px 0;" src="https://raw.githubusercontent.com/nikbearbrown/Google_Colab/master/QDH/graphs/QDH_Long_Banner.png" />
</div>
<div id="conclusion" class="section level2">
<h2>Conclusion</h2>
<p>In this article I explored the idea of extending the “data humanism” of Giorgia Lupi by using the roughness and sketchiness to quantitively display additional information. I call this approach <em>Quantitive Data Humanism</em> or <em>QDH</em>. The “noise” in the sketchy style of can be used to coney important information in a graph. In particular, it naturally fits with conveying uncertainty. QDH has the benefit of not only dimishing the stylistic issues with computer-generated, harsh-toned graphs, it has the potential to add many additional parameters that can reflect statistical properties in the underlying data.</p>
</div>
<div id="design-notes" class="section level2">
<h2>Design Notes</h2>
<p>I’d like this to be a <em>Medium</em> and <em>arXiv </em> article in the not too distant future. The design is intentionally kept simple so it can essentially be cut and pasted into <a href="https://medium.com">medium.com</a> and fit seemlessly and easily adpated to the <a href="https://arxiv.org">https://arxiv.org/</a> LaTeX format.</p>
<pre><code>


</code></pre>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
